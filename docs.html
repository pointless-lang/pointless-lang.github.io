<!DOCTYPE html>
<html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Pointless: docs</title>

      <link rel="stylesheet" type="text/css" href="style.css">
      <link rel="stylesheet" type="text/css" href="highlight/highlight.css">
      <link rel="stylesheet" media="screen" href="fonts/fonts.css" type="text/css"/>

      <style type="text/css">
        .contentsRow {
          margin-top: 4px;
        }

        .contentsRow a {
          margin-left: 10px;
        }

        .sectionName {
          font-weight: bold;
          display: inline-block;
          width: 200px;
        }

        .sectionName a {
          margin: 0px;
        }

        hr {
          margin: 40px 0px;
        }

        code {
          padding: 2px 6px;
          border-radius: 2px;
          background-color: #ddd;
        }

        .sample {
          margin: 20px 0px 40px 0px;
        }

        a h3 {
          margin-top: 40px;
        }
      </style>

  </head>

  <body>
    <main>
      <a href="/">
        <header>
          <pre>
     ___           ___           ___           ___          ___            ___        ___           ___           ___     
    /\  \         /\  \         /\  \         /\__\        /\  \          /\__\      /\  \         /\  \         /\  \    
   /::\  \       /::\  \        \:\  \       /::|  |       \:\  \        /:/  /     /::\  \       /::\  \       /::\  \   
  /:/\:\  \     /:/\:\  \        \:\  \     /:|:|  |        \:\  \      /:/  /     /:/\:\  \     /:/\ \  \     /:/\ \  \  
 /::\~\:\  \   /:/  \:\  \   ___ /::\  \   /:/|:|  |__      /::\  \    /:/  /     /::\~\:\  \   _\:\~\ \  \   _\:\~\ \  \ 
/:/\:\ \:\__\ /:/__/ \:\__\ /\  /:/\:\__\ /:/ |:| /\__\    /:/\:\__\  /:/__/     /:/\:\ \:\__\ /\ \:\ \ \__\ /\ \:\ \ \__\
\/__\:\/:/  / \:\  \ /:/  / \:\/:/  \/__/ \/__|:|/:/  /   /:/  \/__/  \:\  \     \:\~\:\ \/__/ \:\ \:\ \/__/ \:\ \:\ \/__/
     \::/  /   \:\  /:/  /   \::/__/          |:/:/  /   /:/  /        \:\  \     \:\ \:\__\    \:\ \:\__\    \:\ \:\__\  
      \/__/     \:\/:/  /     \:\  \          |::/  /    \/__/          \:\  \     \:\ \/__/     \:\/:/  /     \:\/:/  /  
                 \::/  /       \:\__\         /:/  /                     \:\__\     \:\__\        \::/  /       \::/  /   
                  \/__/         \/__/         \/__/                       \/__/      \/__/         \/__/         \/__/     </pre>
                       
        </header>
      </a>

      <nav>
        <a href="/"><span>HOME</span></a>
        <a href="online/index.html"><span>ONLINE</span></a>
        <a href="docs.html"><span>DOCUMENTATION</span></a>
        <a href="examples.html"><span>EXAMPLES</span></a>
        <a href="api/index.html"><span>API</span></a>
        <a href="install.html"><span>INSTALL</span></a>
        <a href="dev.html"><span>DEVELOPMENT</span></a>
      </nav>

      <div class="text">
        <h3>Documentation</h3>

        <div class=contentsRow>
          <div class="sectionName">
            <a href="#gettingStarted">Getting Started:</a>
          </div>

          <a href="#helloWorld">Hello World!</a>,
          <a href="#comments">Comments</a>
        </div>

        <div class=contentsRow>
          <div class="sectionName">
            <a href="#basicTypes">Basic Types:</a>
          </div>

          <a href="#numbers">Numbers</a>,
          <a href="#strings">Strings</a>,
          <a href="#booleans">Booleans</a>,
          <a href="#labels">Labels</a>
        </div>

        <div class=contentsRow>
          <div class="sectionName">
            <a href="#conditionals">Conditionals:</a>
          </div>

          <a href="#if">If</a>,
          <a href="#cond">Cond</a>
        </div>

        <div class=contentsRow>
          <div class="sectionName">
            <a href="#definitions">Definitions:</a>
          </div>

          <a href="#variables">Variables</a>,
          <a href="#functions">Functions</a>,
          <a href="#where">Where</a>
        </div>

        <div class=contentsRow>
          <div class="sectionName">
            <a href="#callingFunctions">Calling Functions:</a>
          </div>

          <a href="#partialApplication">Partial Application</a>,
          <a href="#pipeOperator">Pipe Operator</a>
        </div>

        <div class=contentsRow>
          <div class="sectionName">
            <a href="#dataStructures">Data Structures:</a>
          </div>

          <a href="#lists">Lists</a>,
          <a href="#arrays">Arrays</a>,
          <a href="#sets">Sets</a>,
          <a href="#dicts">Dicts</a>,
          <a href="#tuples">Tuples</a>,
          <a href="#objects">Objects</a>
        </div>

        <div class=contentsRow>
          <div class="sectionName">
            <a href="#comprehensions">Comprehensions:</a>
          </div>

          <a href="#for">For</a>,
          <a href="#when">When</a>
        </div>

        <div class=contentsRow>
          <div class="sectionName">
            <a href="#laziness">Laziness:</a>
          </div>

          <a href="#lists">Lists</a>,
          <a href="#defs">Defs</a>
        </div>

        <div class=contentsRow>
          <div class="sectionName">
            <a href="#laziness">Performance:</a>
          </div>

          <a href="#tailCallOptimization">Tail-Call Optimization</a>,
          <a href="#concatenation">Concatenation</a>
        </div>

        <div class=contentsRow>
          <div class="sectionName">
            <a href="#equality">Equality:</a>
          </div>

          <a href="#basicComparison">Basic Types</a>,
          <a href="#structureComparison">Data Structures</a>,
          <a href="#labelComparison">Label Comparison</a>
        </div>

        <div class=contentsRow>
          <div class="sectionName">
            <a href="#updates">Persistent Updates:</a>
          </div>

          <a href="#viaWith">Via With</a>,
          <a href="#viaUpdateFunctions">Via Update Functions</a>
        </div>

        <div class=contentsRow>
          <div class="sectionName">
            <a href="#io">IO:</a>
          </div>

          <a href="#outputCommands">Output Commands</a>,
          <a href="#debug">Debug</a>
          <a href="#inputCommands">Input Commands</a>
        </div>

        <div class=contentsRow>
          <div class="sectionName">
            <a href="#imports">Imports:</a>
          </div>

          <a href="#importStatements">Import Statements</a>
          <a href="#exportStatements">Export Statements</a>
        </div>

        <div class=contentsRow>
          <div class="sectionName">
            <a href="#errors">Errors and Exceptions:</a>
          </div>

          <a href="#errors">Errors</a>,
          <a href="#exeptionsThrow">Exceptions / Throw</a>,
          <a href="#tryCatch">Try / Catch</a>,
          <a href="#requires">Requires</a>
        </div>

        <div class=contentsRow>
          <div class="sectionName">
            <a href="#prelude">Prelude:</a>
          </div>

          <a href="#specialFieldWrappers">Special Field Wrappers</a>
        </div>

        <br>
        <hr>

        <h3 id="gettingStarted">
          <a href="#gettingStarted">Getting Started:</a>
        </h3>

        <p>See the <a href="install.html">install page</a> for instructions on downloading, building, and running Pointless.</p>

        <h4 id="helloWorld">
          <a href="#helloWorld">Hello World!</a>
        </h4>

        <p>This code implements the classic "Hello World!" program in Pointless:</p>

        <div class="sample">
          <pre class="highlight">output = println("Hello World!")</pre>
        </div>

        <h4 id="comments">
          <a href="#comments">Comments</a>
        </h4>

        <p>
          Comments in Pointless begin with two dashes '--' and span the rest of the line. Comments can be placed on the same line as code (following the code), or on their own line, as seen below. A long bar of dashes can be used to separate blocks of code and provide documentation for functions.
        </p>
        
        <div class="sample">
          <pre class="highlight">-----------------------------------------------------------
-- check whether a number is even - returns true for even
-- ints, false for odd ints or non-int numbers

isEven(n) = n % 2 == 0 -- even ints equal zero mod 2</pre>
        </div>

        <hr>

        <h3 id="basicTypes">
          <a href="#basicTypes">Basic Types:</a>
        </h3>

        <p>Pointless has four basic types: numbers, strings, booleans, and labels.</p>

        <h4 id="numbers">
          <a href="#numbers">Numbers</a>
        </h4>

        <p>
          All numbers in Pointless use double-precision floating-point representation. Pointless supports a number of common mathematical operations.
        </p>
        
        <div class="sample">
          <pre class="highlight">-- numerical operations:
a + b   -- addition
a - b   -- subtraction
a * b   -- multiplication
a / b   -- division
a % b   -- modulus
a ** b  -- exponentiation

-- inequality operations:
a < b   -- less-than
a > b   -- greater-than
a <= b  -- less-than or equal-to
a >= b  -- greater-than or equal-to</pre>
        </div>        

        <h4 id="strings">
          <a href="#strings">Strings</a>
        </h4>

        <p>
          In Pointless, strings are the fundamental type for representing pieces of text - Pointless has no character type. Two strings can be concatenated into a new string using the <code>+</code> operator.
        </p>

        <div class="sample">
          <pre class="highlight">-- an empty string
a = ""

-- an non-empty string
b = "I lost the game"

-- string addition
c = b + ", again!"</pre>
        </div>

        <h4 id="booleans">
          <a href="#booleans">Booleans</a>
        </h4>

        <p>
          Booleans in Pointless are represented with the keywords 'true' and 'false'.
        </p>

        <div class="sample">
          <pre class="highlight">-- booleans
a = true
b = false

-- boolean operations:
[a and b, a or b, not a]</pre>
        </div>

        <h4 id="labels">
          <a href="#labels">Labels</a>
        </h4>

        <p>
          Labels in Pointless are like symbols in Lisp - they can be used much like enumeration values in other language, except that the enumeration doesn't have to be explicitly declared. Label names start with a capital latter, and can contain alphanumeric characters.
        </p>
        
        <div class="sample">
          <pre class="highlight">-- some labels
a = North
b = Level3
c = C</pre>
        </div>

        <hr>

        <h3 id="conditionals">
          <a href="#conditionals">Conditionals:</a>
        </h3>

        <p>
          Pointless has two conditional constructs <code>if</code> and <code>switch</code>, which are used to select the value of one of several expression based on boolean conditions.
        </p>

        <h4 id="if">
          <a href="#if">If</a>
        </h4>

        <p>
          If conditionals follow the form <code>if [condition] then [then expression] else [else expression]</code>. If expressions can be broken into multiple lines for readability. If expressions can be nested, as in the second example below, where the else of the first conditional is a second conditional. Note that the expressions in the <code>then</code> and <code>else</code> branches are not evaluated unless the branch is selected by the condition.
        </p>

        <div class="sample">
          <pre class="highlight">-- a simple conditional
getSign(n) = if n >= 0 then Positive else Negative

-- a nested conditional
getSignZero(n) =
  if n > 0 then Positive
  else if n < 0 then Negative
  else Zero

output = range(-3, 3) |> map(getSignZero) |> println</pre>
        </div>

        <h4 id="cond">
          <a href="#cond">Cond</a>
        </h4>

        <p>
          Cond conditionals consist of one or more cases of the form <code>case [condition] [result]</code>. When a cond is evaluated, the conditions are evaluated in-order; when a case is found with a true condition, the cond conditional returns the value of the result expression for the case. A cond conditional can also include a default case of the form <code>otherwise [result]</code> (the default case must come last in the list of cases). The value of the default case will used if no case conditions are true. If no conditions are satisfied and the cond has no default case, the conditional will raise an error.
        </p>

        <p>As in if conditionals, the result expressions of cases are evaluated lazily.</p>

        <p>In the example below, the first cond returns a label based on a number; the second cond returns a string based on a label value.</p>

        <div class="sample">
          <pre class="highlight">-- a cond statement with a default case
getSignZero(n) = cond {
  case n > 0 Positive
  case n < 0 Negative
  else Zero
}

-- a cond statement with no default
getSignSymbol(sign) = cond {
  case is(Positive, sign) "+"
  case is(Negative, sign) "-"
  case is(Zero, sign)     "0"
}

output = getSignZero(-4) |> getSignSymbol |> println</pre>
        </div>

        <hr>

        <h3 id="definitions">
          <a href="#definitions">Definitions:</a>
        </h3>

        <p>
          As seen in the previous section, conditionals in Pointless are themselves expression - they evaluate to a value. A Pointless program is made up entirely of expressions and definitions - Pointless does not have explicit execution flow, unlike imperative programming languages. Furthermore, every expression in a program must be part of a definition - Pointless doesn't allow functions to be called without using the resulting value as many other languages do.
        </p>

        <p>
          All definitions occur in a scope. Constructs like functions, where expressions, and objects create new local scopes for their parameters / definitions. Local scopes form closures over non-local variables.
        </p>

        <h4 id="variables">
          <a href="#variables">Variables</a>
        </h4>

        <p>
          Variable definitions take the form <code>[variableName] = [expression]</code>. Variable names start with a lowercase letter and can contain alphanumeric characters. A variable name can only be defined once in a given scope.
        </p>

        <div class="sample">
          <pre class="highlight">-- some variable definitions
n = 1024
isEven = n % 2 == 0
isDiv3 = n 3 2 == 0</pre>
        </div>

        <h4 id="functions">
          <a href="#functions">Functions</a>
        </h4>

        <p>
          Function definitions take the form <code>functionName(param1, param2, param3) = [functionBody]</code> (for any number of parameters >= 1). Parameters must be valid variable names (alpha-numeric, beginning with a lower-case letter).
        </p>

        <div class="sample">
          <pre class="highlight">double(n) = n * 2</pre>
        </div>

        <p>
          Functions may be defined recursively, as in the factorial example below.
        </p>
        
        <div class="sample">
          <pre class="highlight">-- an (inefficient) recursive factorial implementation

factorial(n) = if n == 0 then 1 else n * factorial(n - 1)</pre>
        </div>

        <p>Functions can also be declared anonymously (lambda functions), shown below:</p>

        <div class="sample">
          <pre class="highlight">-- a single-parameter lambda function
n => n + 1

-- a multi-parameter lambda function
(a, b) => a + b</pre>
        </div>

        <p>
          Under the hood, function definitions de-sugar to assignment to a lambda function, such that the following two lines are equivalent:
        </p>

        <div class="sample">
          <pre class="highlight">double(n) = n * 2
double = n => n * 2</pre>
        </div>

        <p>
          Writing, (and more importantly, reading) programs in Pointless is often easiest when functionality is divided among many small functions and definitions. For example, the following code:
        </p>

        <div class="sample">
          <pre class="highlight">output = longestPair |> println

longestPair =
  range(1, 99)
  |> map(getLengthPair)
  |> argmax(at(0))
 
getLengthPair(n) = (length(getSeq(n)), n)

getSeq(n) =
  iterate(step, n)
  |> takeUntil(eq(1))
 
step(n) =
  if n % 2 == 0 then round(n / 2) else n * 3 + 1</pre>
        </div>

        <p>would be preferred over the equivalent condensed code:</p>

        <div class="sample">
          <pre class="highlight">output = range(1, 99)
  |> map(n =>
    (length(
      takeUntil(eq(1), iterate(n =>
        if n % 2 == 0
        then round(n / 2)
        else n * 3 + 1, n))), n))
  |> argmax(at(0))
  |> println</pre>
        </div>

        <h4 id="where">
          <a href="#where">Where</a>
        </h4>

        <p>
          A where expression can be used to create new scopes and define local variables. These expressions take the form expression <code>[expression] where [definitions]</code>. A where expression with a single definition (an intermediate value used in the function) is shown below.
        </p>

        <div class="sample">
          <pre class="highlight">volume(radius, height) =
  base * height
  where base = pi * radius ** 2</pre>
        </div>

        <p>Alternatively, a where clause can contain a curly-bracketed group of multiple definitions.</p>

        <div class="sample">
          <pre class="highlight">distance(x1, y1, x2, y2) = sqrt(dx ** 2 + dy ** 2) where {
  dx = x1 - x2
  dy = y1 - y2
  sqrt(n) = n ** .5
}</pre>
        </div>

        <hr>

        <h3 id="callingFunctions">
          <a href="#callingFunctions">Calling Functions:</a>
        </h3>

        <p>
          Functions call syntax uses parentheses around group of comma-separated argument expressions:
        </p>        

        <div class="sample">
          <pre class="highlight">mul(a, b) = a * b
output = println(mul(2, 3))</pre>
        </div>

        <p>
          Calling a function with more arguments than it has parameters results in an error.
        </p>

        <h4 id="partialApplication">
          <a href="#partialApplication">Partial Application</a>
        </h4>

        <p>
          When a function is called with fewer arguments than its number of parameters ("partial application"), a new function object is created which will accept the remaining function parameters, while storing the already-supplied argument values. In the example below, triple is a function which takes one parameter (b). When triple is called, it returns value of the original function mul called with the stored value for param a (3) and the new value for b (2).
        </p>

        <div class="sample">
          <pre class="highlight">mul(a, b) = a * b
triple = mul(3)
output = println(triple(2))</pre>
        </div>

        <h4 id="pipeOperator">
          <a href="#pipeOperator">Pipe Operator</a>
        </h4>

        <p>
          Function calls can also be expressed using the function-pipe operator <code>|></code>, where <code>a |> b</code> is equivalent to <code>b(a)</code>, and <code>a |> b |> c</code> is equivalent to <code>c(b(a))</code>, and so on. Thus, the following call:
        </p>

        <div class="sample">
          <pre class="highlight">output = println(range(3))</pre>
        </div>

        <p>could instead be expressed as like this:</p>

        <div class="sample">
          <pre class="highlight">output = range(3) |> println</pre>
        </div>

        <p>
          Chaining function calls through the pipe operator can increase the legibility of otherwise nested calls. For example, the following code:
        </p>

        <div class="sample">
          <pre class="highlight">output = println(map(mul(2), range(3)))</pre>
        </div>

        <p>
          could instead be written as a sequence of transformations:
        </p>

        <div class="sample">
          <pre class="highlight">output = range(3) |> map(mul(2)) |> println</pre>
        </div>

        <hr>

        <h3 id="dataStructures">
          <a href="#dataStructures">Data Structures:</a>
        </h3>

        <p>
          Pointless has a number of built-in data-structures - that is, types which contain other types within them. These data-structure types are: lists, arrays, sets, dicts, tuples, and objects. The examples below demonstrate the basic methods for creating and interacting with data-structure in Pointless. See the prelude <a href="api">api docs</a> for many more data-structure-related functions.
        </p>

        <h4 id="lists">
          <a href="#lists">Lists</a>
        </h4>

        <p>
          A list is used to store an iterable sequence of values. Unlike arrays, in which elements can be accessed through numerical indecies, list elements can only be accessed through iteration. Lists are created through the syntax below: a square-bracket-enclosed comma-separated sequence of values. An empty list is represented with empty brackets <code>[]</code>, or equivalently with the label <code>Empty</code>. The function <code>head</code> returns the first value in a list, the function <code>tail</code> returns a list of all values after the first. Calling <head>head</head> or <code>tail</code> on an empty list results in an error.</p>

        <div class="sample">
          <pre class="highlight">-- a list of numbers
numbers = [1, 2, 3]

a = head(numbers) -- 1
b = tail(numbers) -- [2, 3]

-- empty list
empty = []</pre>
        </div>

        <p>
          Two lists can be concatenated with the concat operator '++' to form a new list. <em>Note that lists (as well as other data-structures) can contain different types of values at once.</em>
        </p>

        <div class="sample">
          <pre class="highlight">a = [] ++ []                  -- []
b = [1] ++ [2, "three"]       -- [1, 2, "three"]
c = [false] ++ ["asdf"] ++ [] -- [false, "asdf"]</pre>
        </div>

        <p>
          The concat operator can be used in recursive functions to build lists procedurally. The <code>collatz</code> function below creates a list containing a collatz sequence starting at a given number:
        </p>

        <div class="sample">
          <pre class="highlight">-- end sequence once 1 is reached 
-- otherwise current value is the start of the output sequence,
-- along with the sequence starting at the next value

collatz(n) =
  if n == 1 then [1]
  else [n] ++ collatz(step(n))

step(n) =
  if n % 2 == 0 then n / 2 else n * 3 + 1</pre>
        </div>

        <p>
          In addition to producing lists, functions can take lists as input and process them recursively, like the <code>take</code> function below, which takes the first <code>n</code> elements from an input list (or fewer if the input list contains fewer than <code>n</code> elements):
        </p>

        <div class="sample">
          <pre class="highlight">take(n, list) = cond {
  case n == 0 []
  case isEmpty(list) []
  -- take one value, and reduce the number of values left to take by one
  else [head(list)] ++ take(n - 1, tail(list))
}</pre>
        </div>

        <h4 id="arrays">
          <a href="#arrays">Arrays</a>
        </h4>

        <p>
          Arrays, like lists, contain sequence of elements, represented by square-bracked enclosed space-separated sequence of values. Unlike lists, arrays have a fixed size (that is, they cannot be extended or concatenated). Their elements are accessed through the index syntax below. Pointless also includes a special syntax for nested two-dimensional arrays, also seen below:
        </p>

        <div class="sample">
          <pre class="highlight">-- an array of numbers
a = [1 2 3]

x = a[0] -- 1 (arrays are zero-indexed)

-- a two-dimensional array of numbers
b = [1 0 -1]
    [2 0 -2]
    [1 0 -1]

y = a[1][2] -- 2 (row 1, column 2)</pre>
        </div>

        <h4 id="sets">
          <a href="#sets">Sets</a>
        </h4>

        <p>
          A set is an unordered collection of unique values. Uniqueness is determined according the language's <a href="#equality">equality rules</a>. The operator <code>in</code> can be used to see if a set contains a given value.
        </p>

        <div class="sample">
          <pre class="highlight">e = toSet([]) -- an empty set

-- an set of labels
directions = {North, East}

x = North in directions -- true
y = South in directions -- false</pre>
        </div>

        <h4 id="dicts">
          <a href="#dicts">Dicts</a>
        </h4>

        <p>
          A dict (dictionary) is an unordered collection of key / value pairs, where each key is unique. As with sets, uniqueness follows <a href="#equality">equality rules</a>. The operator <code>in</code> is used to check whether the keys of a dict contain a given key value. The value associated with a given key in a dict can be accessed with the syntax <code>dict[key]</code> as seen below. Note that attempting to look up a non-existing key in a dict results in an error. 
        </p>

        <div class="sample">
          <pre class="highlight">-- an empty dict
e = {}

-- an dict of from strings to numbers
values =
  {"pawn": 1, "knight": 3, "bishop": 3, "rook": 5, "queen": 9}

x = "pawn" in values -- true
y = "king" in values -- false

pawnVal = values["pawn"] -- 1</pre>
        </div>

        <h4 id="tuples">
          <a href="#tuples">Tuples</a>
        </h4>

        <p>
          A tuple is a ordered group of values. Unlike a list or array, the elements in a tuple normally serve different purposes, and are often different types. The values in a tuple are accessed through destructuring assignment, as shown below:
         </p>

        <div class="sample">
          <pre class="highlight">-- an two-element tuple
point = (3, 4)

-- destructuring assignment
(x, y) = point</pre>
        </div>

       <p>
          Tuples can also have labels - labeled tuples can be created using the function <code>wrap</code> (to make a single-element tuple with a given label) or the function <code>wrapTuple</code> (to make a labeled tuple from an unlabeled tuple). Pointless also has special syntax for creating labeled tuples, where <code>SomeLabel(val)</code> is equivalent to <code>wrap(SomeLabel, val)</code> and <code>SomeLabel(valA, valB, valC)</code> is equivalent to <code>wrapTuple(SomeLabel, (valA, valB, valC))</code> for any number of values >= 2:
       </p>

        <div class="sample">
          <pre class="highlight">-- a tree structure made with labeled tuples
tree = Branch(Leaf(1), Branch(Leaf(2), Leaf(3)))

-- making a tuple by calling wrap with a label stored in a variable
label = Leaf
l = wrap(label, 0) -- Leaf(0)</pre>
        </div>

        <p>
          The label of a tuple can be checked using the <code>is</code> function:
        </p>

        <div class="sample">
          <pre class="highlight">-- a tree structure made with labeled tuples
tree = Branch(Leaf(2), Leaf(3))

x = is(Branch, tree) -- true
y = is(Leaf, tree)   -- false</pre>
        </div>

        <h4 id="objects">
          <a href="#objects">Objects</a>
        </h4>

        <p>
          An object is a set of definitions - as in where expressions, these can be variable definitions or function definitions. The fields (definitions) within an object can be accessed through using the syntax <code>objectValue.fieldName</code> show below:
        </p>

        <div class="sample">
          <pre class="highlight">-- an object
pet = {
  age = 4
  name = "rufus"
}

output =
  format("{}, age {}", [pet.name, pet.age])
  |> println</pre>
        </div>

        <p>
           Like tuples, objects can also have labels. Labeled objects can be created using the function <code>wrapObject</code>, which makes a labeled object from an unlabeled object. Pointless also has special syntax for creating labeled objects, where <code>SomeLabel {definitions}</code> is equivalent to <code>wrapObject(SomeLabel, {definitions})</code>. The label of a tuple can be checked using the <code>is</code> function:
        </p>

        <div class="sample">
          <pre class="highlight">-- a labeled object
lilah = Cat {
  age = 12
  name = "lilah"
}

x = is(Dog, lilah) -- false
y = is(Cat, lilah) -- true</pre>
        </div>

        <hr>

        <h3 id="comprehensions">
          <a href="#comprehensions">Comprehensions:</a>
        </h3>

        <p>
          List comprehension syntax provides another way to create lists in Pointless. A list comprehension expression takes the form <code>for [variable] in [values] [body]</code>, where the body of the comprehension is either a yield statement or another comprehension. The yield statement marks the expression used to generate the elements in the resulting list (the <code>yield</code> keyword is necessary to disambiguate nested comprehensions). To generate the new list, the given variable name is assigned to each value in the values list, and the body expression is evaluated to create new elements in the output list:
        </p>

        <h4 id="for">
          <a href="#for">For</a>
        </h4>

        <div class="sample">
          <pre class="highlight">-- starting with a list of numbers 1 through 10, generate
-- a new list containing the squares of these numbers

squares = for n in range(1, 10) yield n ** 2

-- generate a list of pairs
-- [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2) ...]

pairs =
  for a in range(0, 2)
  for b in range(0, 2)
  yield (a, b)</pre>
        </div>

        <h4 id="when">
          <a href="#when">When</a>
        </h4>

        <p>
          Comprehensions can also include when expressions of the form <code>when [condition] [body]</code>, where the body expression is evaluated only when the condition is met - otherwise no elements are returned for that iteration of the comprehension. When expressions can be used to filter the output from a comprehensions:
        </p>

        <div class="sample">
          <pre class="highlight">-- generate a list of pairs
-- [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1), (2, 2)]

pairs =
  for a in range(0, 2)
  for b in range(0, 2)
  when a >= b
  yield (a, b)</pre>
        </div>

        <p>List comprehensions are syntactic sugar - the precise semantics of for, when and yield can be understood by looking at canonical forms that the parser translates these expressions to:</p>

        <div class="sample">
          <pre class="highlight">for var in iter body
-- becomes
concatMap(var => body, iter)

when test body
-- becomes
if test then body else []

yield body
-- becomes
[body]</pre>
        </div>

        <hr>

        <h3 id="laziness">
          <a href="#laziness">Laziness:</a>
        </h3>

        <p>
          Expressions in Pointless are normally evaluated eagerly. There are exceptions to this rule, like the branches of conditional expressions, as described previously. There are two other important instances where the language introduces laziness: lists and definitions.
        </p>

        <h4 id="lists">
          <a href="#lists">Lists</a>
        </h4>

        <p>Lists introduce laziness in two ways: first, the elements in a list expression are not evaluated until the elements themselves are accessed (using the <code>head</code> function). Second, when two lists are concatenated, the right-hand value in the concatenation is not evaluated until it is accessed (when traversing the list using the <code>tail</code> function). As a result of this, functions with recursive calls on the right-hand side of a concatenation expression can be used to generate infinite lists, as seen in the example below, which continuously generates new list elements and prints them to the console.</p>

        <div class="sample">
          <pre class="highlight">repeat(value) = [value] ++ repeat(value)

output =
  repeat("How long till we get there?")
  |> enumerate
  |> printLines</pre>
        </div>

        <p>
          The Pointless prelude contains many functions that can process infinite lists - for example the take function, which can be used to make finite list from an infinite list:
        </p>

        <div class="sample">
          <pre class="highlight">zeroToNine = iterate(add(1), 0) |> take(10)</pre>
        </div>

        <p>
          Note that list comprehensions can also be used to process and generate lazy lists.
        </p>

        <h4 id="defs">
          <a href="#defs">Defs</a>
        </h4>

        <p>
          Like lists, the values of definitions are also calculated lazily. Specifically, when a new set of definitions is encountered (in the global scope, a where clause, an object, etc), all definitions are registered in the new scope before any are evaluated. As a result, the order of definitions in a program does not matter, as shown in the example below:
        </p>

        <div class="sample">
          <pre class="highlight">a = 1

output = [a, b, c] |> println

b = 2
c = 3</pre>
        </div>

        <p>
          <em>Note that unlike other definitions, arguments to functions are calculated eagerly.</em>
        </p>

        <p>
          Normally, accessing the value of a circularly-defined variable will result in a call-stack overflow. However, lazy definitions allow some types of recursive structures to be defined - for example recursive objects. While it is possible to use these recursive structures in some situations (as shown below), using them with other operations, like the <code>show</code> function, will make the program enter in infinite loop:
        </p>

        <div class="sample">
          <pre class="highlight">x = {myself = x; value = 123}

a = show(x.myself.myself.value) -- "123"
b = show(x) -- loops infinitely</pre>
        </div>

        <hr>

        <h3 id="laziness">
          <a href="#laziness">Performance:</a>
        </h3>

        <p>
          Notes on two important performance considerations when writing programs in Pointless.
        </p>

        <h4 id="tailCallOptimization">
          <a href="#tailCallOptimization">Tail-Call Optimization</a>
        </h4>

        <p>
          Pointless performs tail-call optimizations during program execution - that is, a function which returns the result of another function call does not extend the call-stack when performing this inner call. The following code, for example, is not in tail-call form and cannot be optimized, since the addition step is performed after the inner call returns. This function would create a call-stack overflow if called on a large list.
        </p>

        <div class="sample">
          <pre class="highlight">sum(list) =
  if list is Empty then 0
  else head(list) + sum(tail(list))

output = sum(range(1000)) |> println</pre>
        </div>

        <p>On the other hand, the following function performs the addition step before making its recursive call, and will thus be tail-call optimized, making it suitable for input lists of arbitrary length:</p>

        <div class="sample">
          <pre class="highlight">sumHelper(result, list) =
  if list is Empty then result
  else sumHelper(head(list) + result, tail(list))

sum = sumHelper(0)

output = sum(range(1000)) |> println</pre>
        </div>

        <h4 id="concatenation">
          <a href="#concatenation">Concatenation</a>
        </h4>

        <p>
          During concatenation, Pointless makes a copy of the left-hand list being concatenated. As a result, the concatenation operation has a time complexity that is linear in the length of the left-hand list. This also means that the concatenation operation only works when the left-hand list has a finite length.
        </p>

        <p>
          On the other hand, the right-hand side list in a concatenation remains lazily evaluated. This means that concatenation operations with a recursive call on the right-hand side are still in tail-recursive form, and can be used to generate infinite, lazy lists, as shown in the repeat function below, which creates an infinite list of a given value, repeated:
        </p>

        <div class="sample">
          <pre class="highlight">repeat(value) = [value] ++ repeat(value)</pre>
        </div>

        <p>
          In situations where lazy concatenation is needed with respect to both the left-hand and right-hand lists, use the <code>concat</code> function from the prelude.
        </p>

        <hr>

        <h3 id="equality">
          <a href="#equality">Equality:</a>
        </h3>

        <p>Notes on the different ways to compare values in Pointless.</p>

        <h4 id="basicComparison">
          <a href="#basicComparison">Basic Types</a>
        </h4>

        <p>
          Basic types (numbers, booleans, strings, and labels) can be compared using the basic equality operators <code>==</code> and <code>!=</code> (note that comparing non-integer numbers using these operators may fail due to floating-point inaccuracies). Additionally, tuples can be compared using the basic equality operators if all of their member values are comparable using these operators.
        </p>

        <div class="sample">
          <pre class="highlight">123 == 123 -- true
123 != 4   -- true</pre>
        </div>

        <h4 id="structureComparison">
          <a href="#structureComparison">Data Structures</a>
        </h4>

        <p>
          For implementation reasons, comparison of other data structures (lists, arrays, sets, maps, objects, and tuples not fitting the criteria above) using the basic equality operators compares these objects according to their location in memory. As a result, comparison of two data-structures will return false even if those structures contain the same values, unless they are two references to the same original structure. Comparison of functions follows the same rule.
        </p>

        <p>
          To overcome this limitation, Pointless defines functions <code>deepEq</code> (and correspondingly <code>deepNotEq</code>), which can be used to perform deep-comparison of data-structures.
        </p>

        <h4 id="labelComparison">
          <a href="#labelComparison">Label Comparison</a>
        </h4>

        <p>As seen previously, the <code>==</code> operator can be used to compare labels Additionally, <code>is</code> can be used to check the labels of tuples and objects, and to determine the type of other values in pointless. For example, the expression <code>is(PtlsNumber, value)</code> can be used to check if a value is a number, <code>is(PtlsBoolean, value)</code> can check booleans, and so on. Note that <code>is(PtlsLabel, value)</code>, <code>is(PtlsTuple, value)</code>, and <code>is(PtlsObject, value)</code>, will also return true for any labels, tuples, and objects, respectively, regardless of their labels. All of the example expressions below will return true:</p>

        <div class="sample">
          <pre class="highlight">
is(PtlsNumber , 123)                 -- number
is(PtlsString , "asdf")              -- string
is(PtlsBool   , true)                -- boolean
is(PtlsLabel  , Foo)                 -- label
is(Foo        , Foo)                 -- label
is(PtlsFunc   , sum)                 -- function
is(PtlsBuiltIn, {}.!getDelKey)       -- built-in
is(PtlsSet    , {1})                 -- set
is(PtlsMap    , {"one": 1})          -- map
is(PtlsList   , ["a", "b"])          -- list
is(PtlsArray  , [0 0 0])             -- array
is(Baz        , Baz {x = 0; y = 2})  -- labeled object
is(PtlsObject , Baz {x = 0; y = 2})  -- labeled object
is(PtlsObject , {x = 0; y = 2})      -- unlabeled object
is(Bar        , Bar(1, 2))           -- labeled tuple
is(PtlsTuple  , Bar(1, 2))           -- labeled tuple
is(PtlsTuple  , (1, 2))              -- unlabeled tuple</pre>
        </div>

        <hr>

        <h3 id="updates">
          <a href="#updates">Persistent Updates:</a>
        </h3>

        <p>
          In Pointless, arrays, sets, dict, objects, and tuples are persistent, immutable types - that is, once created, their values cannot be changed. Instead, Pointless provides several ways to create new data-structures based on old ones, depending on their types.
        </p>

        <h4 id="viaWith">
          <a href="#viaWith">Via With</a>
        </h4>

        <p>
          With expressions can be used to create new arrays, dict, and objects from old ones. These expressions take the form <code>[value] with [updateDefinitions]</code>. In an update definition, the character <code>$</code> is used to represent the structure being updated. With expressions work by first cloning the original structure, and, for each update definition, updating the value of some index or field in the original new. The value returned by the with statement is the value of cloned structure once all updates have been applied. In the below example, the <code>newValues</code> is a clone of <code>values</code> with its first element (zero index) set to the value zero. 
        </p>

        <div class="sample">
          <pre class="highlight">values = [1 2 3]
newVals = values with $[0] = 0 -- [0 2 3]</pre>
        </div>

        <p>
          With expressions can contain multiple update definitions, as in the example below. As with where expressions, with expressions with multiple definitions must wrap these definitions in curly brackets. The below with statement returns a clone of the original array with the elements at indecies zero and one swapped. Note that the right hand sides of the update definitions are calculate before the updates are processed - which allows the swap to occur without using a temporary variable.
        </p>

        <div class="sample">
          <pre class="highlight">values = [4 10]

newVals = values with { -- newVals = [10 4]
  $[0] = values[1]
  $[1] = values[0]
}</pre>
        </div>

        <p>
          <em>Note that updates are processed in order from top to bottom, which is relevant if a later update overrides an earlier update.</em>
        </p>

        <p>
          The following example demonstrates the nested update of an object containing a map and an object in its fields.
        </p>     

        <div class="sample">
          <pre class="highlight">structure = Data {
  foo = [-1 0 -1]
  bar = {"green": false}
}

-- newStruct = Data {foo = [-1 0 1]; bar = {"green": false, "blue": true}}
newStruct = structure with {
  $.foo[2] = 1
  $.bar["green"] = false
  $.bar["blue"] = true
}</pre>
        </div>

        <p>
          <em>Note that Pointless uses efficient representations for persistent structures so as to avoid the cost of fully copying structures when performing updates.</em>
        </p>

        <h4 id="viaUpdateFunctions">
          <a href="#viaUpdateFunctions">Via Update Functions</a>
        </h4>

        <p>
          The Pointless prelude provides the following functions for adding elements to sets, and deleting elements and key / value pairs from sets and dict, respectively. Note that deleting a non-existing element or key from a set or dict has no effect.
        </p>

        <div class="sample">
          <pre class="highlight">addElem({1, 2}, 3)        -- {1, 2, 3}
delElem({1, 2}, 2)        -- {1}
delElem({1, 2}, 0)        -- {1, 2}
delKey({Foo: "bar"}, Foo) -- {}</pre>
        </div>

        <hr>

        <h3 id="io">
          <a href="#io">IO:</a>
        </h3>

        <p>Notes on the input / output capabilities of Pointless.</p>

        <h4 id="outputCommands">
          <a href="#outputCommands">Output Commands</a>
        </h4>

        <p>
          Unlike other programming language, which use functions to send information from a program to the outside system, Pointless programs communicate their output through a sequence of output commands. To accomplish this, Pointless designates a special variable, <code>output</code>, from which output commands are read when an program is run. Some programming languages have a main method, which serves as the entry-point for executing the program - in Pointless, the output variable also serves as an entry-point, where the value of the output variable is the output from the program.
        </p>

        <p>
          Pointless expects the output variable to be defined as a list of commands. Commands can be either labels or labeled values - the two output commands which Pointless currently supports are <code>IOPrint(value)</code>, which directs the Pointless interpreter to print the string value, and <code>IOClearConsole</code>, which clears the console. The top-level source file for a Pointless program must define an output variable, and the value of output must be a valid list of commands - programs which do not meet these requirements will cause an error at runtime.
        </p>

        <p>
          Since lists in Pointless are processed lazily, the sequence of output commands defined by a program will also be handled lazily. This means that, while programs must define a single entry-point for their output, that output is still handled as the programming running, rather than blocking until the program terminates.
        </p>

        <div class="sample">
          <pre class="highlight">IOPrint(value)
IOClearConsole</pre>
        </div>

        <p>
          To avoid interacting with these output commands directly, the Pointless prelude defines the following functions to help generate output sequences. The <a href="examples.html">examples</a> page demonstrates the many uses for these functions.
        </p>

        <div class="sample">
          <pre class="highlight">print(value)       -- generate command sequence to print the string rep for value
println(value)     -- generate command sequence to print value with a newline
printFrame(value)  -- generate command sequence to clear console and print value with newline
printLines(values) -- print each element in a sequence on a separate line</pre>
        </div>

        <p>
          Because output sequences are made up of normal Pointless values, they themselves can be manipulated and visualized. In the example below, the code <code>printLines(range(3))</code> generates a command sequence to print the numbers zero through two - the code then calls the <code>println</code> function again to print a string representation of these commands. Running this code thus provides a visualization of a typical output command sequence.
        </p>

        <div class="sample">
          <pre class="highlight">output = printLines(range(3)) |> println</pre>
        </div>

        <h4 id="debug">
          <a href="#debug">Debug</a>
        </h4>

        <p>
          Sometimes when debugging, the task of integrating debugging output into the larger output stream of the program is cumbersome. Pointless therefore provides a special function <code>debug</code> which does the following:
        </p>

        <ol>
          <li>Takes a single value as an argument</li>
          <li>Prints <code>show(value)</code> to the console</li>
          <li>Prints the code location where the value was created</li>
          <li>Returns the value</li>
        </ol>

        <h4 id="inputCommands">
          <a href="#inputCommands">Input Commands</a>
        </h4>

        <p>
          At present, Pointless provides two input sources - lines read from stdin, and random numbers. These inputs are accessible through special fields on the IO label, shown below:
        </p>

        <div class="sample">
          <pre class="highlight">IO.!getLines -- a lazy list of input lines
IO.!getRand  -- a random decimal value (between 0 and 1)</pre>
        </div>

        <p>
          As with other special fields, the prelude has definitions for accessing these inputs, including the <code>readLines</code> and several functions for generating random numbers / choices.
        </p>

        <div class="sample">
          <pre class="highlight">readLines         -- read lines of input lazily
randFloat(n)      -- get random float in range(n)
randRange(a, b)   -- get random entry from range(a, b)
randChoice(elems) -- get random elem from collection</pre>
        </div>

        <p>
          While the set of input choices is currently limited, the existing input sources can be easily processed using existing functions. For example, the following code reads lines from stdin, and prints the length of each line.
        </p>

        <div class="sample">
          <pre class="highlight">output = readLines |> map(length) |> printLines</pre>
        </div>

        <hr>

        <h3 id="imports">
          <a href="#imports">Imports:</a>
        </h3>

        <p>Import statements are used to share code across multiple source files.</p>

        <h4 id="importStatements">
          <a href="#importStatements">Import Statements</a>
        </h4>

        <p>
          Import statements have the form <code>import "filePath" as [name]</code>. By default, import statement will load all of the definitions from the given source file and return these in object, which is then stored in the specified name. All import statements in a program must come before any variable or function definitions. Circular imports are allowed (two files can both import each other, for example), although this will make the import objects themselves contain circular references.
        </p>

        <div class="sample">
          <pre class="highlight">import "chart.ptls" as chart</pre>
        </div>        

        <h4 id="exportStatements">
          <a href="#exportStatements">Export Statements</a>
        </h4>

        <p>
          To avoid importing helper methods, a source file can specify a set of names that are importable using an export statements of the form <code>export {name1, name2, name3}</code> for any number of names. When a file with an export statement is imported, only the specified names will available to the importing file. Note that an export statement (if a file contains one) must come before all imports and definitions.
        </p>

        <div class="sample">
          <pre class="highlight">export {
  foo,
  bar,
  baz, -- trailing comma ok
}</pre>
        </div>

        <hr>

        <h3 id="errors">
          <a href="#errors">Errors and Exceptions:</a>
        </h3>

        <p>
          Pointless programs use both errors and exceptions to signal erroneous states - however, these mechanisms arise in different scenarios and are handled in different ways.
        </p>

        <h4 id="errors">
          <a href="#errors">Errors</a>
        </h4>

        <p>
          Errors in Pointless are caused by invalid code which the interpreter is unable to handle. Some issues which result in errors include:
        </p>

        <ul>
          <li>Invalid syntax</li>
          <li>Calling an operation with the wrong types of arguments (like adding two booleans)</li>
          <li>Destructuring a tuple to the wrong number of members</li>
          <li>Stack overflows caused by circular definitions or buggy recursive functions</li>
          <li>Accessing a nonexistent field in an object</li>
        </ul>

        <p>
          When an error occurs in a Pointless program, the program stops running and reports the error. Programs cannot recover from errors.
        </p>

        <p>
          Errors can sometimes be prevented before they occur. Functions can be adapted to check for certain erroneous conditions before performing an operation that could lead to an error. For example, indexing a dict with a key that the dict does not contain will result in an error - this could be prevented by wrapping a dict access in a conditional which check that the dict contains the required key before attempting to index the dict, and falling back to some other behavior if the key is not present:
        </p>

        <div class="sample">
          <pre class="highlight">if key in dict then dict[key] else somethingElse</pre>
        </div>

        <p>
          Similar techniques could be used to prevent other errors including:
        </p>

        <ul>
          <li>Division by zero</li>
          <li>taking the head or tail of an empty list</li>
          <li>Indexing an array with an out-of-bounds index</li>
          <li>Indexing an array with a non-integer value</li>
        </ul>

        <h4 id="exeptionsThrow">
          <a href="#exeptionsThrow">Exceptions / Throw</a>
        </h4>

        <p>
          Unlike errors, exceptions in Pointless are explicitly thrown, and must be caught and handled. Exceptions are thrown using expressions of the form <code>throw [value]</code>. Exceptions are useful in situations where indicating error states using return values would significantly complicate a function's API (see the <a href="examples.html#tokenizer">self-hosting tokenizer</a> example). However, exceptions can introduce their own complexity, and should primarily be used internally (that is, not part of the API of exported functions). An unhandled exception (an exception which isn't handled anywhere in a program) results in an error.
        </p>

        <h4 id="tryCatch">
          <a href="#tryCatch">Try / Catch</a>
        </h4>

        <p>
          Exceptions are handled using try / catch expressions of the form <code>try [body] catch [conditionFunc] [handlerFunc]</code>. If an exception occurs while evaluating the body expression, then the condition function is called on the value of the exception. If the condition function returns true, then the handler function is called on the exception value and the result is returned as the value of the entire  try / catch expression. If the condition function returns false, then the exception continues to propagate. If no exception is thrown in the body expression, then its value is returned as the value of the entire  try / catch expression.
        </p>

        <p>
          The following code from the <a href="examples.html#tokenizer">self-hosting tokenizer</a> example catches and prints tokenizer errors:
        </p>

        <div class="sample">
          <pre class="highlight">output =
  try
    new(text)
    |> getTokens
    |> convert
    |> map(showTok)
    |> eager
    |> printLines

  catch const(TokenizerError)
    err => println(unwrap(err))</pre>
        </div>

        <p>
          In the code above, the function <code>eager</code> is used to force complete evaluation of the tokens list in order to catch errors before it is returned from the try / catch expression.
        </p>

        <h4 id="requires">
          <a href="#requires">Requires</a>
        </h4>

        <p>
          Requires statements are similar to assertions in other programming languages - they provide an easy way to check that a condition is met and throw an error if it is not. Unlike assertions, requires statements are attached to a specific expression, and take the form <code>[expression] requires [condition]</code>, where the condition is checked before the expression is evaluated. This allows functions to verify preconditions before they run, as in the following function, which returns the last element in a list after checking that the list is not empty.
        </p>

        <div class="sample">
          <pre class="highlight">last(list) = head(reverse(list)) requires list is PtlsList</pre>
        </div>        

        <hr>

        <h3 id="prelude">
          <a href="#prelude">Prelude:</a>
        </h3>

        <p>
          The prelude is the <a href="https://github.com/pointless-lang/pointless/tree/master/lib/prelude">set of files</a> which contain the definitions for the Pointless standard library. API documentation for all prelude functions can be found <a href="api">here</a>.
        </p>

        <h4 id="specialFieldWrappers">
          <a href="#specialFieldWrappers">Special Field Wrappers</a>
        </h4>

        <p>
          Values in Pointless have a number of special fields of the form <code>.!get[FieldName]</code>, for example <code>"123".!getInt</code> (get the integer value of the string), <code>{false}.!getAddElem</code> (get the cloned set with the added element), and so on, which are used to expose built-in functions of Pointless types. The prelude contains wrapper functions for accessing this functionality, for example <code>toInt</code> and <code>addElem</code>, which wrap access to the fields above. Avoid accessing special fields directly - use the provided wrapper functions instead (the APIs of the wrappers are more stable than those of the fields themselves).
        </p>

        <hr>
      </div>

      <footer>
        <div>copyright (c) 2020 Avery N. Nortonsmith</div>
        <div>logo based on isometric1 by Kent Nassen</div>
      </footer>
    </main>
      
    <script src="highlight/js/highlightGen.js"></script>
    <script src="highlight/js/highlight.js"></script>

  </body>
</html>
