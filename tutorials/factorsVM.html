
<!DOCTYPE html>
<html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Pointless: tutorials -- Writing a VM for a Small Stack-Base Language in Pointless</title>

      <link rel="stylesheet" type="text/css" href="../style.css">
      <link rel="stylesheet" type="text/css" href="style.css">
      <link rel="stylesheet" type="text/css" href="../highlight/highlight.css">
      <link rel="stylesheet" media="screen" href="pointlessSite/fonts/fonts.css" type="text/css"/>

      <style type="text/css">
        p {
          margin: 24px 0px;
        }
      </style>

  </head>

  <body>
    <main>
      <a href="/">
        <header>
          <pre>
     ___           ___           ___           ___          ___            ___        ___           ___           ___     
    /\  \         /\  \         /\  \         /\__\        /\  \          /\__\      /\  \         /\  \         /\  \    
   /::\  \       /::\  \        \:\  \       /::|  |       \:\  \        /:/  /     /::\  \       /::\  \       /::\  \   
  /:/\:\  \     /:/\:\  \        \:\  \     /:|:|  |        \:\  \      /:/  /     /:/\:\  \     /:/\ \  \     /:/\ \  \  
 /::\~\:\  \   /:/  \:\  \   ___ /::\  \   /:/|:|  |__      /::\  \    /:/  /     /::\~\:\  \   _\:\~\ \  \   _\:\~\ \  \ 
/:/\:\ \:\__\ /:/__/ \:\__\ /\  /:/\:\__\ /:/ |:| /\__\    /:/\:\__\  /:/__/     /:/\:\ \:\__\ /\ \:\ \ \__\ /\ \:\ \ \__\
\/__\:\/:/  / \:\  \ /:/  / \:\/:/  \/__/ \/__|:|/:/  /   /:/  \/__/  \:\  \     \:\~\:\ \/__/ \:\ \:\ \/__/ \:\ \:\ \/__/
     \::/  /   \:\  /:/  /   \::/__/          |:/:/  /   /:/  /        \:\  \     \:\ \:\__\    \:\ \:\__\    \:\ \:\__\  
      \/__/     \:\/:/  /     \:\  \          |::/  /    \/__/          \:\  \     \:\ \/__/     \:\/:/  /     \:\/:/  /  
                 \::/  /       \:\__\         /:/  /                     \:\__\     \:\__\        \::/  /       \::/  /   
                  \/__/         \/__/         \/__/                       \/__/      \/__/         \/__/         \/__/     </pre>
                       
        </header>
      </a>

      <nav>
        <a href="/"><span>HOME</span></a>
        <a href="../online/"><span>ONLINE</span></a>
        <a href="../docs.html"><span>DOCS</span></a>
        <a href="../examples.html"><span>EXAMPLES</span></a>
        <a href="../api/index.html"><span>API</span></a>
        <a href="../install.html"><span>INSTALL</span></a>
        <a href="../dev.html"><span>DEVELOPMENT</span></a>
        <a href="../tutorials/"><span>TUTORIALS</span></a>
      </nav>

      <div class="text">
        <h3>Tutorial: Writing a VM for a Small Stack-Base Language in Pointless</h3>

        <h3>This tutorial is a work in progress -- please don't share</h3>

        <p>
          This tutorial covers the implementation of a <strong>virtual-machine</strong> for a small, <strong>stack-based</strong> language in Pointless. We'll take an <strong>incremental</strong> approach to building the VM and improving its capabilities until it can run a short <strong>prime-factorization</strong> program.
        </p>
      </div>

      <div class="text">
        This project seeks to demonstrate:

        <ul style="margin-bottom: 0px;">
          <li>
            How an imperative language can be implemented in a purely functional context
          </li>

          <li>
            How to structure and refactor code that uses persistent data-structures
          </li>

          <li>
            How Pointless can -- even as a young language -- be used to solve non-trivial tasks
          </li>
        </ul>
      </div>

      <div class="text">
        <p>
          Before we tackle prime-factorization, let's take a look at a small example of the stack-based code that our VM will evaluate. The following Pointless code defines a <a href="../docs.html#lists">list</a> of 'instructions', where <a href="../docs.html#tuples">labeled-tuples</a> are used to represent instructions with an argument, and <a href="../docs.html#labels">labels</a> are used to represent zero-argument instructions. A list of instructions like this represents a program in our stack-based language.
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
program = [
  Const(7),
  Const(2),
  Mod,
  Const(0),
  Eq,
  Print,
  Exit,
]
</pre>
      </div>

      <div class="text">
        <p>
          Let's take a minute to write a function for pretty-printing these instruction lists 
          -- this will come in handy later when we work with more complex programs.
          The function <code>showInst</code> below takes an instruction and returns as string showing the instruction name (left-justified to 5 characters) and instruction argument. The function <code>argOrBlank</code> returns the argument if the instruction has one, or an empty string otherwise. 
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
showInst(inst) =
 format("[ {<5} ] {}", [getLabel(inst), argOrBlank(inst)])

argOrBlank(inst) =
  if is(PtlsTuple, inst) then unwrap(inst) else ""
</pre>
      </div>

      <div class="text">
        <p>
          In the code above, <code><a href="../api/prelude/format.html#format">format</a></code>, <code><a href="../api/prelude/label.html#getLabel">getLabel</a></code>, <code><a href="../api/prelude/types.html#is">is</a></code>, and <code><a href="../api/prelude/label.html#unwrap">unwrap</a></code> are defined in the Pointless <a href="../api/index.html">prelude</a> (standard-library).
        </p>

        <p>
          To see that this code works, we'll define an output variable for our program. 
          In Pointless, a program's output is defined by its output variable.
          The prelude contains functions like <code><a href="../api/prelude/io.html#printLines">printLines</a></code> which generate sequences of IO commands that can be assigned to this output variable.
        </p>

        <p>
          The output definition below takes our list of instructions, generates a new list of instruction-strings by calling <code>showInst</code> on each instruction, and produces IO commands to print each instruction-string on a separate line.
          In the sample output below we've put or code in a file called <code>main.ptls</code>, although this name doesn't matter. See also: docs for the function <a href="../docs.html#pipeOperator">pipe operator</a> <code>|></code>, and for <a href="../docs.html#partialApplication">partial application</a>.
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> map(showInst)
  |> printLines
</pre>

      <pre class="result">
$ ./bin/pointless main.ptls

[ Const ] 7
[ Const ] 2
[ Mod   ] 
[ Const ] 0
[ Eq    ] 
[ Print ] 
[ Exit  ]
</pre>
      </div>

      <div class="text">
        <p>Time to start making our VM.</p>

        <p>
          We'll represent the VM using an object with the following five fields:
        </p>

        <ul>
          <li><code>slots</code>: used to store "heap" variables (discussed later on)</li>
          <li><code>insts</code>: an array containing the program's instructions</li>
          <li><code>index</code>: position in instruction array of the current instruction</li>
          <li><code>stack</code>: linked-list serving as the stack for the VM</li>
          <li><code>outVal</code>: used to get output from VM as program runs</li>
        </ul>

        <p>
          The function <code>vmFromInsts</code> sets up a new VM object for a given list of instructions. The code also adds the label <code>VM</code> to the VM object (objects and tuples can be labeled in Pointless). Object labels can be used to write code that tells different types of objects apart; however we do it here simply for documentation.
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
vmFromInsts(program) = VM {
  slots  = zeroArray(8)
  insts  = toArray(program)
  index  = 0
  stack  = []
  outVal = None
}
</pre>
      </div>

      <div class="text">
        <p>
          To check that <code>vmFromInsts</code> works, we'll modify our output definition to create and print a new VM object. Note that we've replaced <code>printLines</code> with <code><a href="../api/prelude/io.html#println">println</a></code> -- <code>printLines</code> expects a sequence of values (and can print these values on-the-fly as they are computed in the case of lists), whereas <code>println</code> can handle sequence and non-sequences types.
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> vmFromInsts
  |> println
</pre>

      <pre class="result">
$ ./bin/pointless main.ptls

VM {stack = []; insts = [Const(7) Const(2) Mod Const(0) Eq Print Exit]; slots = [0 0 0 0 0 0 0 0]; index = 0; outVal = None}
</pre>
      </div>

      <div class="text">
        <p>
          We run the program, and see that <code>println</code> gives us a nice visualization of our initial VM object. 
        </p>

        <p>
          Let's look again at our list of instructions:
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
program = [
  Const(7),
  Const(2),
  Mod,
  Const(0),
  Eq,
  Print,
  Exit,
]
</pre>
      </div>

      <div class="text">
        <p>
          The instructions above are designed to do the following:
        </p>

        <ul>
          <li><code>Const(arg)</code> pushes <code>arg</code> onto the VM stack</li>
          <li><code>Mod</code> pops values <code>v0</code> and <code>v1</code> from the stack, and pushes <code>v1 % v0</code></li>
          <li><code>Eq</code> pops values <code>v0</code> and <code>v1</code> from the stack, and pushes <code>v1 == v0</code></li>
          <li><code>Print</code> pops a value from the stack and prints it</li>
          <li><code>Exit</code> signals the end of the program</li>
        </ul>

        <p>
          Additionally, each of these instructions will advance the VM to the next instruction after performing the behaviors above.
        </p>

        <p>
          With this in mind, we see that the program above does the following: loads the values <code>7</code> and <code>2</code> onto the stack, computes <code>7 % 2</code>, loads the value <code>0</code>, compares <code>0</code> with the result of <code>7 % 2</code>, prints the result of this comparison, and exits. In other words, this program tells us whether or not <code>7</code> is even.
        </p>

        <p>
          Now that we've defined some instructions, let's start evaluating them.
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
eval(vm) = cond {
  case is(Const, vm.insts[vm.index])
    vm with $.stack = [unwrap(vm.insts[vm.index])] ++ vm.stack
}
</pre>
      </div>

      <div class="text">
        <p>
          Our <code>eval</code> function uses a <code><a href="../docs.html#cond">cond</a></code> conditional -- eventually this will include cases for all instructions, but we'll start with just <code>Const</code> for now. The code above calls the function <code><a href="../api/prelude/types.html#is">is</a></code> to check whether the current instruction has the label <code>Const</code> (the current instruction is the instruction in the <code>vm.insts</code> array at index <code>vm.index</code>). If <code>is</code> returns true, then conditional evaluates and returns the body of the case expression.
        </p>

        <p>
          Structures in Pointless persistent, and thus immutable. As such, our program will never mutate the state of a VM object; rather, it will produce new VM objects. The code above uses <a href="../docs.html#viaWith">with syntax</a> to create a new VM object with a new stack value: the old stack with the instruction argument pushed to the top (we use the <code>unwrap</code> function to get the argument from the <code>Const</code> instruction).
        </p>

        <p>
          The code above is dense and repetitive; we can improve it by defining a couple of variables. In the new version, <code>inst</code> is the current instruction, and the <code>arg</code> is the argument of that instruction.
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
eval(vm) = cond {
  case is(Const, inst)
    vm with $.stack = [arg] ++ vm.stack

} where {
  inst = vm.insts[vm.index]
  arg = unwrap(inst)
}
</pre>
      </div>

      <div class="text">
        <p>
          We modify the program's output definition to call <code>eval</code> on the VM to evaluate the first instruction, <code>Const(7)</code>. Looking at output, we see that the value <code>7</code> has been pushed to the stack (<code>insts</code> field for abbreviated for readability).
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> vmFromInsts
  |> eval
  |> println
</pre>

      <pre class="result">
$ ./bin/pointless main.ptls

VM {stack = [7]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 0; outVal = None}
</pre>
      </div>

      <div class="text">
        <p>
          We need our <code>Const</code> instruction to do one more thing -- advance the VM to the next instruction. To do this, we'll make a new helper function <code>advance</code> that takes a VM object and returns new VM object with the instruction index incremented. We'll also move the code for pushing a value onto the VM stack into the new function <code>pushVal</code>.
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
advance(vm) = vm with $.index += 1

pushVal(arg, vm) = vm with $.stack = [arg] ++ vm.stack
</pre>
      </div>

      <div class="text">
        <p>
          Using these two new functions, the code for <code>eval</code> becomes:
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
eval(vm) = cond {
  case is(Const, inst)
    vm
    |> pushVal(arg)
    |> advance

} where {
  inst = vm.insts[vm.index]
  arg = unwrap(inst)
}
</pre>

      <pre class="result">
$ ./bin/pointless main.ptls

VM {stack = [7]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 1; outVal = None}
</pre>
      </div>

      <div class="text">
        <p>
          We call the program again and get the result seen above: the new VM object returned by <code>eval</code> has the value <code>7</code> on its stack and its index incremented.
        </p>

        <p>
          At this point, the entire program looks something like this (note that the comment bars are not necessary, but are helpful for dividing code visually; they can also be used to mark API documentation):
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> vmFromInsts
  |> eval
  |> println

------------------------------------------------------------------------------

program = [
  Const(7),
  Const(2),
  Mod,
  Const(0),
  Eq,
  Print,
  Exit,
]

------------------------------------------------------------------------------

showInst(inst) =
 format("[ {<5} ] {}", [getLabel(inst), argOrBlank(inst)])

argOrBlank(inst) =
  if is(PtlsTuple, inst) then unwrap(inst) else ""

------------------------------------------------------------------------------

vmFromInsts(program) = VM {
  slots  = zeroArray(8)
  insts  = toArray(program)
  index  = 0
  stack  = []
  outVal = None
}

------------------------------------------------------------------------------

eval(vm) = cond {
  case is(Const, inst)
    vm
    |> pushVal(arg)
    |> advance

} where {
  inst = vm.insts[vm.index]
  arg = unwrap(inst)
}

------------------------------------------------------------------------------

advance(vm) = vm with $.index += 1

pushVal(arg, vm) = vm with $.stack = [arg] ++ vm.stack
</pre>
      </div>

      <div class="text">
        <p>
          Let's keep going.
        </p>

        <p>
          The <code>Const</code> instruction pushes values onto the stack; other instructions will need to access and pop values from the stack. We introduce two new functions to help with this: <code>valAt(n, vm)</code> returns the value at depth <code>n</code> on the VM stack; <code>popVals(n, vm)</code> returns a VM object with the top <code>n</code> stack values removed.
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
valAt(n, vm) = at(n, vm.stack)

popVals(n, vm) = vm with $.stack = drop(n, vm.stack)
</pre>
      </div>

      <div class="text">
        <p>
          We use these two functions to create a case for our first numerical operation, <code>Mod</code>:
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
case is(Mod, inst)
  vm
  |> popVals(2)
  |> pushVal(valAt(1, vm) % valAt(0, vm))
  |> advance
</pre>
      </div>

      <div class="text">
        <p>
          The <code>Mod</code> instruction pops the top two values from the stack -- <code>v0</code> and <code>v1</code> -- and pushes the value <code>v1 % v0</code> to the stack (<code>Mod</code> expects the divisor to be at the top of the stack, and the dividend beneath it). The VM is then advanced to the next instruction.
        </p>

        <p>
          It may look like this code to pops <code>v0</code> and <code>v1</code>   before accessing them with <code>valAt</code>; remember however that <code>popVals</code> does not modify the VM object, but rather creates a new one. Thus <code>valAt(1, vm)</code> and <code>valAt(0, vm)</code> refer to the VM object before the values are popped.
        </p>

        <p>
          To test our implementation for <code>Mod</code>, we'll temporarily modify our program as follows:
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
program = [
  Const(7),
  Const(2),
  Mod,
  -- Const(0),
  -- Eq,
  -- Print,
  Exit,
]
</pre>
      </div>

      <div class="text">
        <p>
          Instead of single calling <code>eval</code> once as before, we not call <code>eval</code> repeatedly using the <code><a href="../api/prelude/function.html#iterate">iterate</a></code> function. This generates a sequence of VM objects where the first element is the initial VM object, and each new element is the VM after one more application of <code>eval</code>. We use <code><a href="../api/prelude/list.html#takeUntil">takeUntil</a></code> to get updated VM objects until the VM object with <code>Exit</code> as its current instruction is reached. Node that the <code>Exit</code> instruction is not evaluated -- it's just there to mark end of the program.
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> vmFromInsts
  |> iterate(eval)
  |> takeUntil(vm => vm.insts[vm.index] == Exit)
  |> printLines
</pre>

      <pre class="result">
$ ./bin/pointless main.ptls

VM {stack = []; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 0; outVal = None}
VM {stack = [7]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 1; outVal = None}
VM {stack = [2, 7]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 2; outVal = None}
VM {stack = [1]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 3; outVal = None}
</pre>
      </div>

      <div class="text">
        <p>
          The lines in the result above show the VM:
        </p>

        <ol>
          <li>In its initial state</li>
          <li>After running <code>Const(7)</code></li>
          <li>After running <code>Const(2)</code></li>
          <li>After running <code>Mod</code></li>
          
        </ol>

        <p>
          The stack of the final VM objects holds the value <code>1</code>, the result of <code>7 % 2</code>, as expected.
        </p>

        <p>
          We can implement a handler for the <code>Eq</code> case similarly to how we handled <code>Mod</code>:
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
case is(Eq, inst)
  vm
  |> popVals(2)
  |> pushVal(valAt(1, vm) == valAt(0, vm))
  |> advance
</pre>
      </div>

      <div class="text">
        <p>
          This leaves us with some duplicated code between handlers for <code>Mod</code> and <code>Eq</code>. We can address this by factoring these handlers out into a helper function for generic binary operations. This new function, <code>binaryOp</code>, takes a binary function as argument (<code>op</code>), which is used to calculate the result that gets pushed to the VM stack.
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
binaryOp(op, vm) =
 vm
 |> popVals(2)
 |> pushVal(op(valAt(0, vm), valAt(1, vm)))
 |> advance
</pre>
      </div>

      <div class="text">
        <p>
          Note that <code>v0</code> comes before <code>v1</code> in <code>binaryOp</code>.  This is done because the prelude functions that we'll pass <code>binaryOp</code> take their arguments in reversed order (for example <code><a href="../api/prelude/numerical.html#mod">mod</a></code> which wraps the operator <code>%</code>). These numerical prelude functions are designed this way with partial application in mind -- it's more useful for <code>mod(2)</code> to mean <code>n => n % 2</code> instead of <code>n => 2 % n</code>. This happens to match the order that the operands will arrive in on the VM stack, so no reversal is needed.
        </p>

        <p>
          We can now rewrite the cases for <code>Mod</code> and <code>Eq</code> like this:
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
case is(Mod, inst)
  vm |> binaryOp(mod)

case is(Eq, inst)
  vm |> binaryOp(eq)
</pre>
      </div>

      <div class="text">
        <p>
          At this point the <code>eval</code> function can handle all instructions in our example program except for <code>Print</code>. We'll comment out the <code>Print</code> instruction and run the program.
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
program = [
  Const(7),
  Const(2),
  Mod,
  Const(0),
  Eq,
  -- Print,
  Exit,
]
</pre>

      <pre class="result">
$ ./bin/pointless main.ptls

VM {stack = []; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 0; outVal = None}
VM {stack = [7]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 1; outVal = None}
VM {stack = [2, 7]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 2; outVal = None}
VM {stack = [1]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 3; outVal = None}
VM {stack = [0, 1]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 4; outVal = None}
VM {stack = [false]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 5; outVal = None}
</pre>
      </div>

      <div class="text">
        <p>
          Our evaluation calculates <code>7 % 2</code> as before, and loads the number <code>0</code>, and compares this to the result of the modulo operation.
        </p>

        <p>
          We need one more helper function to implement the case for the <code>Print</code> instruction. Our new function <code>setOutput</code> takes an argument value and sets the <code>.outVal</code> field on the updated VM object to this value.
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
setOutput(val, vm) = vm with $.outVal = val
</pre>
      </div>

      <div class="text">
        <p>
          The handler for the <code>Print</code> instruction pops a value from the VM stack, sets the VM <code>.outVal</code> field to this value, and advances the VM:
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
case is(Print, inst)
  vm
  |> popVals(1)
  |> setOutput(valAt(0, vm))
  |> advance
</pre>
      </div>

      <div class="text">
        <p>
          Now we can update our output definition to get the output from our VM. Instead of printing the value of the VM object on each evaluation loop, we instead get the value of the <code>.outVal</code> field of each VM object using <code>map(vm => vm.outVal)</code>, and print each of these values on a new line using <code>printLines</code>. We also want to clear the <code>.outVal</code> field before each instruction runs, so we modify our call to <code>iterate</code> to call <code>setOutput(None)</code> on each VM object before calling <code>eval</code>. As before, we run the iteration loop until the <code>Exit</code> instruction is reached:
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> vmFromInsts
  |> iterate(compose(setOutput(None), eval))
  |> takeUntil(vm => vm.insts[vm.index] == Exit)
  |> map(vm => vm.outVal)
  |> printLines
</pre>

      <pre class="result">
$ ./bin/pointless main.ptls

None
None
None
None
None
None
false
</pre>
      </div>

      <div class="text">
        <p>
          The numerical instructions yield no print output, while the <code>Print</code> instruction yields the output value <code>false</code> -- the result of <code>7 % 2 == 1</code>.
        </p>

        <p>
          To keep the definition for the output variable simple, we'll refactor our output code into a new function, <code>runGetOutput</code>, which takes a list of instructions, creates a new VM object, evaluates the instructions, and get the VM output.           <code>runGetOutput</code> also uses the <code><a href="../api/prelude/list.html#filter">filter</a></code> function discard the <code>None</code> outputs that come from the non-<code>Print</code> instructions.
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
runGetOutput(insts) =
  vmFromInsts(insts)
  |> iterate(compose(setOutput(None), eval))
  |> takeUntil(vm => vm.insts[vm.index] == Exit)
  |> map(vm => vm.outVal)
  |> filter(notEq(None))
</pre>
      </div>

      <div class="text">
        <p>
          Our new output definition calls <code>runGetOutput</code> and produces the result below, which tells us that, unsurprisingly, 7 is not even.
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> runGetOutput
  |> printLines
</pre>

      <pre class="result">
$ ./bin/pointless main.ptls

false
</pre>
      </div>

      <div class="text">
        <p>
          Here's what our current program looks like:
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> runGetOutput
  |> printLines

runGetOutput(insts) =
  vmFromInsts(insts)
  |> iterate(compose(setOutput(None), eval))
  |> takeUntil(vm => vm.insts[vm.index] == Exit)
  |> map(vm => vm.outVal)
  |> filter(notEq(None))

------------------------------------------------------------------------------

program = [
  Const(7),
  Const(2),
  Mod,
  Const(0),
  Eq,
  Print,
  Exit,
]

------------------------------------------------------------------------------

showInst(inst) =
 format("[ {<5} ] {}", [getLabel(inst), argOrBlank(inst)])

argOrBlank(inst) =
  if is(PtlsTuple, inst) then unwrap(inst) else ""

------------------------------------------------------------------------------

vmFromInsts(program) = VM {
  slots  = zeroArray(8)
  insts  = toArray(program)
  index  = 0
  stack  = []
  outVal = None
}

------------------------------------------------------------------------------

eval(vm) = cond {
  case is(Const, inst)
    vm
    |> pushVal(arg)
    |> advance

  case is(Print, inst)
    vm
    |> popVals(1)
    |> setOutput(valAt(0, vm))
    |> advance

  case is(Mod, inst) vm |> binaryOp(mod)
  case is(Eq, inst)  vm |> binaryOp(eq)

} where {
  inst = vm.insts[vm.index]
  arg = unwrap(inst)
}

------------------------------------------------------------------------------

advance(vm)        = vm with $.index += 1
pushVal(arg, vm)   = vm with $.stack = [arg] ++ vm.stack
popVals(n, vm)     = vm with $.stack = drop(n, vm.stack)
setOutput(val, vm) = vm with $.outVal = val

valAt(n, vm) = at(n, vm.stack)

binaryOp(op, vm) =
 vm
 |> popVals(2)
 |> pushVal(op(valAt(0, vm), valAt(1, vm)))
 |> advance
</pre>
      </div>

      <div class="text">
        <p>
          Dope.
        </p>
        <p>
          Let's look at our prime-factorization program:
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
n = 80122

program = [
  Const(2),
  Store(0),            -- store value 2 in slot 0 (initial divisor)
  Const(n),
  Store(1),            -- store value n in slot 1 (initial dividend)
  Label("checkDone"),
  Load(1),             -- load dividend
  Const(1),
  Eq,                  -- compare dividend to value 1
  JmpIf("end"),        -- jump to end if dividend == 1
  Label("checkDiv"), 
  Load(1),             -- load dividend
  Load(0),             -- load divisor
  Mod,
  Const(0),
  Eq,                  -- compare dividend % dividor == 0 
  JmpIf("divisible"),
  Load(0),             -- load divisor
  Const(1),
  Add,                 -- increment divisor
  Store(0),            -- store new divisor
  Jmp("checkDiv"),     -- check end condition
  Label("divisible"),
  Load(0),             -- load divisor
  Print,               -- print divisor (current factor)
  Load(1),             -- load dividend
  Load(0),             -- load divisor
  Div,
  Store(1),            -- store dividend / divisor as new dividend
  Jmp("checkDone"),    -- check end condition
  Label("end"),
  Const("done"),
  Print,               -- print "done"
  Exit,
]
</pre>
      </div>

      <div class="text">
        <p>
          This prime-factorization program is more complex than our previous example. It makes use of the VM's variable slots for "long term" storage -- slots serve as the VM's "heap" and are accessed by integer "addresses" (indicies). In this program, the current factor being tested (the divisor) lives in slot 0, and the current number whose factor is being calculated (the dividend) lives in slot 1.
        </p>

        <p>
          The prime-factorization program also uses some new instructions:
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
Add, Div, Load, Store, Jmp, JmpIf
</pre>
      </div>

      <div class="text">
        <p>
          These instructions behave as follows:
          <ul>
            <li>
              <code>Add</code> pops values <code>v0</code> and <code>v1</code> from the stack, pushes <code>v1 + v0</code>, and advances
            </li>

            <li>
              <code>Div</code> pops values <code>v0</code> and <code>v1</code> from the stack, pushes <code>v1 / v0</code>, and advances
             </li>

            <li>
              <code>Load(arg)</code> pushes the value in the slot at index <code>arg</code> to stack, and advances
             </li>

            <li>
              <code>Store(arg)</code> pops value <code>v0</code>, stores <code>v0</code> in the slot at index <code>arg</code>, and advances
             </li>

            <li>
              <code>Jmp(arg)</code> sets VM instruction index to <code>arg</code>
             </li>

            <li>
              <code>JmpIf(arg)</code> pops value <code>v0</code>, sets VM instruction index to <code>arg</code> if <code>v0 == true</code>, otherwise advances vm
             </li>
          </ul>
        </p>

        <p>
          The instructions <code>Jmp</code> and <code>JmpIf</code> take numerical arguments, but in the program above they have string arguments. The program also contains <code>Label</code> instructions whose argument strings mark the target locations of the corresponding jump instructions. Before evaluating our new program, we'll need to write code that converts these string jump targets into numerical indicies and removes the <code>Label</code> instructions. That code start with the following:
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
getLabelInds(insts) =
  insts
  |> reduce(scanInst, (0, {})) -- keep track of (currentIndex, indexMap)
  |> at(1) -- return index map

scanInst(pair, inst) = 
  if not is(Label, inst)
  then (ind + 1, inds)
  else (ind, newInds)
  where {
    newInds = inds with $[unwrap(inst)] = ind
    (ind, inds) = pair
  }
</pre>
      </div>

      <div class="text">
        <p>
          <code>getLabelInds</code> uses the <code><a href="../api/prelude/list.html#reduce">reduce</a></code> function to iterate through the given instructions list while keeping track of the current index (not counting <code>Label</code> instructions)
          as well as a table matching jump target strings with instruction indicies. After iterating through all of the instructions, <code>getLabelInds</code> returns this table. 
        </p>

        <p>
          <code>scanInst</code> (called for each instruction by <code>getLabelInds</code>) takes the pair (current index, index table) and the current instruction in the list and adds the instruction to the index table if the instruction is a <code>Label</code>, and increments the current index otherwise.
        </p>

        <p>
          The output definition below displays the index table calculated for the prime-factorization program instructions:
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> getLabelInds
  |> println
</pre>
        <pre class="result">
$ ./bin/pointless main.ptls

{"checkDone": 4, "divisible": 19, "checkDiv": 8, "end": 26}
</pre>
      </div>

      <div class="text">
        <p>
          To produce the instructions that the VM will run, we'll need to filter out the <code>Label</code> instructions and replace the target strings of jump instructions with indicies. The function <code>convertJumps</code> does both of these things, using the index table calculated with <code>getLabelInds</code>. To do this, <code>convertJumps</code> calls the helper function <code>convertJump</code>, which translates jump instructions using the index table obtained from <code>getLabelInds</code>.
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
convertJumps(insts) =
  insts
  |> filter(notIs(Label))
  |> map(convertJump(inds))
  where inds = getLabelInds(insts)

convertJump(inds, inst) = cond {
  case is(Jmp, inst) Jmp(inds[unwrap(inst)])
  case is(JmpIf, inst) JmpIf(inds[unwrap(inst)])
  else inst
}
</pre>
      </div>

      <div class="text">
        <p>
          To see the result, we'll modify our output definition to call <code>convertJumps</code> and use the function <code>showInst</code> from before to get string representations for each resulting instruction. In addition to this, we'll call <code><a href="../api/prelude/list.html#enumerate">enumerate</a></code> to get <code>(index, value)</code> pairs for each instruction string, and use <code>format("{>2} {}")</code> to print each instruction string along with its index (to help locate the new numerical targets of the jump instructions).
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> convertJumps
  |> map(showInst)
  |> enumerate
  |> map(format("{>2} {}"))
  |> printLines
</pre>
        <pre class="result">
$ ./bin/pointless main.ptls

 0 [ Const ] 2
 1 [ Store ] 0
 2 [ Const ] 80122
 3 [ Store ] 1
 4 [ Load  ] 1
 5 [ Const ] 1
 6 [ Eq    ] 
 7 [ JmpIf ] 26
 8 [ Load  ] 1
 9 [ Load  ] 0
10 [ Mod   ] 
11 [ Const ] 0
12 [ Eq    ] 
13 [ JmpIf ] 19
14 [ Load  ] 0
15 [ Const ] 1
16 [ Add   ] 
17 [ Store ] 0
18 [ Jmp   ] 8
19 [ Load  ] 0
20 [ Print ] 
21 [ Load  ] 1
22 [ Load  ] 0
23 [ Div   ] 
24 [ Store ] 1
25 [ Jmp   ] 4
26 [ Const ] done
27 [ Print ] 
28 [ Exit  ] 
</pre>
      </div>

      <div class="text">
        <p>
          We see above that <code>convertJumps</code> replaced the old jump targets with indicies, and removed the old <code>Label</code> instructions. Now we can update <code>vmFromInsts</code> to call <code>convertJumps</code>:
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
vmFromInsts(program) = VM {
  slots  = zeroArray(8)
  insts  = toArray(convertJumps(program))
  index  = 0
  stack  = []
  outVal = None
}
</pre>
      </div>

      <div class="text">
        <p>
          Time to implement the last few instruction handlers. We'll write the following helper methods for accessing and writing to the VM's slots -- <code>load</code> pushes the value at slot index <code>arg</code> to the VM stack, and <code>store</code> saves the value at the top of the VM stack to slot index <code>arg</code>.  
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
load(arg, vm) = pushVal(vm.slots[arg], vm)

store(arg, vm) = vm with $.slots[arg] = head(vm.stack)
</pre>
      </div>

      <div class="text">
        <p>
          We implement the handlers for the <code>Load</code> and <code>Store</code> instructions like this:
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
case is(Load, inst)
  vm
  |> load(arg)
  |> advance

case is(Store, inst)
  vm
  |> store(arg)
  |> popVals(1)
  |> advance
</pre>
      </div>

      <div class="text">
        <p>
          We can see these definitions in action using one of our previous output definitions (which shows intermediate VM states), along with a short example program:
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> vmFromInsts
  |> iterate(eval)
  |> takeUntil(vm => vm.insts[vm.index] == Exit)
  |> printLines

program = [
  Const(1),
  Store(0), -- store 1 in slot 0
  Load(0),  -- load 1 from slot 0
  Const(2),
  Mul,      -- 2 * 1 = 2
  Store(1), -- store 2 in slot 1
  Load(1),  -- load 2 from slot 1
  Const(2),
  Mul,      -- 2 * 2 = 4
  Store(0), -- store 4 in slot 1
  Exit,
]
</pre>
        <pre class="result">
$ ./bin/pointless main.ptls

VM {stack = []; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 0; outVal = None}
VM {stack = [1]; insts = ...; slots = [0 0 0 0 0 0 0 0]; index = 1; outVal = None}
VM {stack = []; insts = ...; slots = [1 0 0 0 0 0 0 0]; index = 2; outVal = None}
VM {stack = [1]; insts = ...; slots = [1 0 0 0 0 0 0 0]; index = 3; outVal = None}
VM {stack = [2, 1]; insts = ...; slots = [1 0 0 0 0 0 0 0]; index = 4; outVal = None}
VM {stack = [2]; insts = ...; slots = [1 0 0 0 0 0 0 0]; index = 5; outVal = None}
VM {stack = []; insts = ...; slots = [1 2 0 0 0 0 0 0]; index = 6; outVal = None}
VM {stack = [2]; insts = ...; slots = [1 2 0 0 0 0 0 0]; index = 7; outVal = None}
VM {stack = [2, 2]; insts = ...; slots = [1 2 0 0 0 0 0 0]; index = 8; outVal = None}
VM {stack = [4]; insts = ...; slots = [1 2 0 0 0 0 0 0]; index = 9; outVal = None}
VM {stack = []; insts = ...; slots = [4 2 0 0 0 0 0 0]; index = 10; outVal = None}
</pre>
      </div>

      <div class="text">
        <p>
          Our last helper function, <code>jumpIf</code>, updates the VM index to the value <code>arg</code> if the value <code>pred</code> is true -- and advances the VM otherwise. 
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
jumpIf(pred, arg, vm) =
  if pred
  then vm with $.index = arg
  else advance(vm)
</pre>
      </div>

      <div class="text">
        <p>
          We use <code>jumpIf</code> to implement handlers for both the <code>Jmp</code> and <code>JmpIf</code> instructions. <code>JmpIf</code> pops a value from the VM stack and passes it as the predicate to <code>jumpIf</code>, along with its target index (the instruction argument). <code>Jmp</code> also passes its target index to <code>jumpIf</code>, and passes <code>true</code> as its predicate, since <code>Jmp</code> instructions always jump.
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
case is(JmpIf, inst)
  vm
  |> popVals(1)
  |> jumpIf(valAt(0, vm), arg)

case is(Jmp, inst)
  vm
  |> jumpIf(true, arg)
</pre>
      </div>

      <div class="text">
        <p>
          The following output definition and example program show <code>JmpIf</code> in action:
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> vmFromInsts
  |> iterate(eval)
  |> takeUntil(vm => vm.insts[vm.index] == Exit)
  |> printLines

program = [
  Const(false),
  JmpIf("skip"), -- top-of-stack is false, don't jump 
  Const("A"),    -- loads "A"
  Const(true),
  JmpIf("skip"), -- top-of-stack is true, jump to "skip"
  Const("B"),    -- (skipped)
  Label("skip"),
  Exit,          -- exits with only "A" on the stack
]
</pre>
        <pre class="result">
$ ./bin/pointless main.ptls

VM {stack = []; insts = ...; vars = [0 0 0 0 0 0 0 0]; index = 0; outVal = None}
VM {stack = [false]; insts = ...; vars = [0 0 0 0 0 0 0 0]; index = 1; outVal = None}
VM {stack = []; insts = ...; vars = [0 0 0 0 0 0 0 0]; index = 2; outVal = None}
VM {stack = ["A"]; insts = ...; vars = [0 0 0 0 0 0 0 0]; index = 3; outVal = None}
VM {stack = [true, "A"]; insts = ...; vars = [0 0 0 0 0 0 0 0]; index = 4; outVal = None}
VM {stack = ["A"]; insts = ...; vars = [0 0 0 0 0 0 0 0]; index = 6; outVal = None}
</pre>
      </div>

      <div class="text">
        <p>
          We add handlers for the remaining binary operations using the <code>binaryOp</code> function from before. Handlers for <code>Sub</code> and <code>Mul</code> and included for completeness.
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
case is(Eq,  inst) vm |> binaryOp(eq)
case is(Add, inst) vm |> binaryOp(add)
case is(Sub, inst) vm |> binaryOp(sub)
case is(Mul, inst) vm |> binaryOp(mul)
case is(Div, inst) vm |> binaryOp(div)
case is(Mod, inst) vm |> binaryOp(mod)
</pre>
      </div>

      <div class="text">
        <p>
          We can now run the entire prime-factorization program using the output definition from before:
        </p>
      </div>

      <div class="sample">
        <pre class="highlight">
output =
  program
  |> runGetOutput
  |> printLines
</pre>
      <pre class="result">
$ ./bin/pointless main.ptls

2
7
59
97
done
</pre>
      </div>

      <div class="text">
        <p>
          Not bad.
        </p>

        <p>
          You can run the final prime-factorization program and VM implementation <a href="../online/factorsVM.html">online</a>. There are many potential numerical programs that the VM can now support -- see this <a href="../online/factorsVM.html">collatz sequence example</a>.
        </p>

        <p>
          Visit the <a href="dev.html">dev page</a> for instructions on installing Pointless locally. Contributions to the language and example code are welcome!
        </p>

        <p>
          Our entire program (split into several file) is shown below:
        </p>
      </div>

      <div class="sample">
        <pre class="fileName">main.ptls</pre>

        <pre class="highlight">
import "stackVM.ptls" as stackVM

------------------------------------------------------------------------------

output =
  program
  |> stackVM.runGetOutput
  |> printLines

------------------------------------------------------------------------------

n = 80122

program = [
  Const(2),
  Store(0),            -- store value 2 in slot 0 (initial divisor)
  Const(n),
  Store(1),            -- store value n in slot 1 (initial dividend)
  Label("checkDone"),
  Load(1),             -- load dividend
  Const(1),
  Eq,                  -- compare dividend to value 1
  JmpIf("end"),        -- jump to end if dividend == 1
  Label("checkDiv"), 
  Load(1),             -- load dividend
  Load(0),             -- load divisor
  Mod,
  Const(0),
  Eq,                  -- compare dividend % dividor == 0 
  JmpIf("divisible"),
  Load(0),             -- load divisor
  Const(1),
  Add,                 -- increment divisor
  Store(0),            -- store new divisor
  Jmp("checkDiv"),     -- check end condition
  Label("divisible"),
  Load(0),             -- load divisor
  Print,               -- print divisor (current factor)
  Load(1),             -- load dividend
  Load(0),             -- load divisor
  Div,
  Store(1),            -- store dividend / divisor as new dividend
  Jmp("checkDone"),    -- check end condition
  Label("end"),
  Const("done"),
  Print,               -- print "done"
  Exit,
]
</pre>
      </div>

      <div class="sample">
        <pre class="fileName">stackVM.ptls</pre>

        <pre class="highlight">
export {
  runGetOutput
}

------------------------------------------------------------------------------

import "instructions.ptls" as instructions

------------------------------------------------------------------------------

vmFromInsts(program) = VM {
  slots  = zeroArray(8)
  insts  = toArray(instructions.convertJumps(program))
  index  = 0
  stack  = []
  outVal = None
}

------------------------------------------------------------------------------

runGetOutput(insts) =
  vmFromInsts(insts)
  |> iterate(compose(setOutput(None), eval))
  |> takeUntil(vm => vm.insts[vm.index] == Exit)
  |> map(vm => vm.outVal)
  |> filter(notEq(None))

------------------------------------------------------------------------------

eval(vm) = cond {
  case is(Const, inst)
    vm
    |> pushVal(arg)
    |> advance

  case is(Print, inst)
    vm
    |> popVals(1)
    |> setOutput(valAt(0, vm))
    |> advance

  case is(Load, inst)
    vm
    |> load(arg)
    |> advance

  case is(Store, inst)
    vm
    |> store(arg)
    |> popVals(1)
    |> advance

  case is(JmpIf, inst)
    vm
    |> popVals(1)
    |> jumpIf(valAt(0, vm), arg)

  case is(Jmp, inst)
    vm
    |> jumpIf(true, arg)

  case is(Eq,  inst) vm |> binaryOp(eq)
  case is(Add, inst) vm |> binaryOp(add)
  case is(Sub, inst) vm |> binaryOp(sub)
  case is(Mul, inst) vm |> binaryOp(mul)
  case is(Div, inst) vm |> binaryOp(div)
  case is(Mod, inst) vm |> binaryOp(mod)

} where {
  inst = vm.insts[vm.index]
  arg = unwrap(inst)
}

------------------------------------------------------------------------------

advance(vm)        = vm with $.index += 1
pushVal(arg, vm)   = vm with $.stack = [arg] ++ vm.stack
popVals(n, vm)     = vm with $.stack = drop(n, vm.stack)
setOutput(val, vm) = vm with $.outVal = val
store(arg, vm)     = vm with $.slots[arg] = head(vm.stack)
load(arg, vm)      = pushVal(vm.slots[arg], vm)

jumpIf(pred, arg, vm) =
  if pred
  then vm with $.index = arg
  else advance(vm) 

valAt(n, vm) = at(n, vm.stack)

binaryOp(op, vm) =
 vm
 |> popVals(2)
 |> pushVal(op(valAt(0, vm), valAt(1, vm)))
 |> advance
</pre>
      </div>

      <div class="sample">
        <pre class="fileName">instructions.ptls</pre>

        <pre class="highlight">
export {
  showInst, makeInstArray
}

------------------------------------------------------------------------------

showInst(inst) =
 format("[ {<5} ] {}", [getLabel(inst), argOrBlank(inst)])

argOrBlank(inst) =
  if is(PtlsTuple, inst) then unwrap(inst) else ""

------------------------------------------------------------------------------

convertJumps(insts) =
  insts
  |> filter(notIs(Label))
  |> map(convertJump(inds))
  where inds = getLabelInds(insts)

------------------------------------------------------------------------------

convertJump(inds, inst) = cond {
  case is(Jmp, inst) Jmp(inds[unwrap(inst)])
  case is(JmpIf, inst) JmpIf(inds[unwrap(inst)])
  else inst
}

------------------------------------------------------------------------------

getLabelInds(insts) =
  insts
  |> reduce(scanInst, (0, {})) -- keep track of (currentIndex, indexMap)
  |> at(1) -- return index map

------------------------------------------------------------------------------

scanInst(pair, inst) = 
  if not is(Label, inst)
  then (ind + 1, inds)
  else (ind, newInds)
  where {
    newInds = inds with $[unwrap(inst)] = ind
    (ind, inds) = pair
  }
</pre>
      </div>

      <footer>
        <div>copyright (c) 2020 Avery N. Nortonsmith</div>
        <div>logo based on isometric1 by Kent Nassen</div>
      </footer>
    </main>

    <script src="../highlight/js/highlightGen.js"></script>
    <script src="../highlight/js/highlight.js"></script>
      
  </body>
</html>
