<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="icon"
      href="/icons/icon.png"
      media="(prefers-color-scheme: light)"
    />
    <link
      rel="icon"
      href="/icons/icon-light.png"
      media="(prefers-color-scheme: dark)"
    />
    <link rel="stylesheet" type="text/css" href="/css/style.css" />
    <title>Caesar Cipher Tutorial</title>
  </head>

  <body>
    <header>
      <a id="logo" href="/">
        <img src="/icons/icon.svg" />
        Pointless
      </a>

      <nav>
        <ul>
          <li><a href="/intro/">Intro</a></li>
          <li><a href="/philosophy/">Philosophy</a></li>
          <li><a href="/language/">Language</a></li>
          <li><a href="/stdlib/">Standard Library</a></li>
          <li><a href="/articles/">Articles</a></li>
        </ul>
      </nav>
    </header>

    <article>
      <div id="title">
        <h1>Caesar Cipher Tutorial</h1>
        <p>Encode and decode text using a Caesar cipher.</p>
      </div>

      <div id="sidebar">
        <a id="back" href="..">< Back to Articles</a>
        <ol>
          <li><a href="#shifting-letters"> Shifting Letters</a></li>
          <li><a href="#shifting-whole-strings"> Shifting Whole Strings</a></li>
          <li><a href="#encoding-and-decoding"> Encoding and Decoding</a></li>
          <li><a href="#uppercase-letters"> Uppercase Letters</a></li>
          <li>
            <a href="#non-alphabetic-characters"> Non-Alphabetic Characters</a>
          </li>
          <li><a href="#wrapping-up"> Wrapping Up</a></li>
        </ol>
      </div>

      <main>
        <p>
          Let&#39;s see an example to get a feel for the language. I&#39;ll show
          you how I wrote the following program, which can encode and decode a
          message using a simple cipher.
        </p>

        <div class="snippet undefined">
          <pre><code class="ptls">alphabet <span class="operator">=</span> <span class="call">chars</span>(<span class="quotes">&quot;</span><span class="string">abcdefghijklmnopqrstuvwxyz</span><span class="quotes">&quot;</span>)

<span class="comment">-- Shift a single letter 13 places</span>

<span class="keyword">fn</span> <span class="function">shift</span>(<span class="argument">letter</span>)
  index <span class="operator">=</span> <span class="std">List</span>.<span class="call">indexOf</span>(alphabet, <span class="std">Str</span>.<span class="call">toLower</span>(letter))

  <span class="keyword">if</span> index <span class="operator">==</span> <span class="constant">none</span> <span class="keyword">then</span>
    letter
  <span class="keyword">else</span>
    shifted <span class="operator">=</span> alphabet[(index <span class="operator">+</span> <span class="number">13</span>) <span class="operator">%</span> <span class="number">26</span>]

    <span class="keyword">if</span> <span class="std">Str</span>.<span class="call">isUpper</span>(letter) <span class="keyword">then</span>
      <span class="std">Str</span>.<span class="call">toUpper</span>(shifted)
    <span class="keyword">else</span>
      shifted
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">-- Encode or decode a message with the ROT13 cipher</span>
<span class="comment">-- https://en.wikipedia.org/wiki/ROT13</span>

<span class="keyword">fn</span> <span class="function">cipher</span>(<span class="argument">message</span>)
  message
    <span class="operator">|</span> <span class="call">chars</span>
    <span class="operator">$</span> <span class="call">shift</span>
    <span class="operator">|</span> <span class="call">join</span>(<span class="quotes">&quot;</span><span class="quotes">&quot;</span>)
<span class="keyword">end</span>

<span class="comment">-- What does this print?</span>

<span class="quotes">&quot;</span><span class="string">Uryyb jbeyq!</span><span class="quotes">&quot;</span>
  <span class="operator">|</span> <span class="call">cipher</span>
  <span class="operator">|</span> <span class="call">print</span></code></pre>
        </div>
        <p>
          The code above implements the <em>ROT13 cipher</em>: a special case of
          the <em>Caesar cipher</em> where each letter in a message is replaced
          with the 13th letter after it in the English alphabet, wrapping around
          to the start if needed.
        </p>
        <pre><code>before encoding: a b c d e f g h i j k l m n o p q r s t u v w x y z
after encoding:  n o p q r s t u v w x y z a b c d e f g h i j k l m</code></pre>
        <p>
          For example, the ROT13 encoding of the word
          <code>&quot;cat&quot;</code> is <code>&quot;png&quot;</code>.
        </p>

        <hr />

        <h2 id="shifting-letters">
          <a href="#shifting-letters">Shifting Letters</a>
        </h2>
        <p>
          To implement the cipher, we start by defining the variable
          <code>alphabet</code> as a list containing the <code>26</code> letters
          of the English alphabet. We do this using the
          <code>chars(string)</code> function to split a string of these letters
          into a list.
        </p>

        <div class="snippet undefined">
          <pre><code class="ptls">alphabet <span class="operator">=</span> <span class="call">chars</span>(<span class="quotes">&quot;</span><span class="string">abcdefghijklmnopqrstuvwxyz</span><span class="quotes">&quot;</span>)</code></pre>

          <pre
            class="result"
            style="undefined"
          ><code><div class="var-name">alphabet</div>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</code></pre>
        </div>
        <p>
          We can use the <code>List.indexOf</code> function to get the index of
          a character within <code>alphabet</code>. For example, the letter
          <code>&quot;i&quot;</code> (the 9th letter in the alphabet) will have
          index <code>8</code> (Pointless lists are <em>0-indexed</em>).
        </p>

        <div class="snippet undefined">
          <pre><code class="ptls"><span class="std">List</span>.<span class="call">indexOf</span>(alphabet, <span class="quotes">&quot;</span><span class="string">i</span><span class="quotes">&quot;</span>)</code></pre>
          <pre class="result" style="undefined"><code>8
</code></pre>
        </div>
        <p>
          In addition to finding the index of a letter, we can also do the
          reverse: get a letter from the alphabet based on its index.
        </p>

        <div class="snippet undefined">
          <pre><code class="ptls">alphabet[<span class="number">8</span>]</code></pre>
          <pre class="result" style="undefined"><code>&quot;i&quot;
</code></pre>
        </div>
        <p>At its core, our cipher will do the following for each letter:</p>
        <ul>
          <li>Convert the letter to an index.</li>
          <li>
            Shift the index value, wrapping back to the start of the alphabet if
            necessary.
          </li>
          <li>Convert the shifted index back to a letter.</li>
        </ul>
        <p>We can write a few lines of code that do just that.</p>

        <div class="snippet undefined">
          <pre><code class="ptls">letter <span class="operator">=</span> <span class="quotes">&quot;</span><span class="string">i</span><span class="quotes">&quot;</span>
index <span class="operator">=</span> <span class="std">List</span>.<span class="call">indexOf</span>(alphabet, letter)
shifted <span class="operator">=</span> alphabet[(index <span class="operator">+</span> <span class="number">13</span>) <span class="operator">%</span> <span class="number">26</span>]</code></pre>

          <pre
            class="result"
            style="undefined"
          ><code><div class="var-name">shifted</div>&quot;v&quot;</code></pre>
        </div>
        <p>
          Here, we&#39;re using <code>(index + 13) % 26</code> as our shifted
          index value. When <code>index + 13</code> is greater than or equal to
          <code>26</code>, the modulus operator will wrap the number back around
          to get a value between <code>0</code> and <code>25</code>. If we
          didn&#39;t use the modulus operator here, our code wouldn&#39;t work
          correctly for letters in the second half of the alphabet.
        </p>
        <p>
          Let&#39;s put this code into a new function called <code>shift</code>.
          The function will take a single letter and return the corresponding
          ROT13 encoded letter. We can use the <code>fn</code> keyword to define
          a new function.
        </p>

        <div class="snippet undefined">
          <pre><code class="ptls"><span class="keyword">fn</span> <span class="function">shift</span>(<span class="argument">letter</span>)
  index <span class="operator">=</span> <span class="std">List</span>.<span class="call">indexOf</span>(alphabet, letter)
  shifted <span class="operator">=</span> alphabet[(index <span class="operator">+</span> <span class="number">13</span>) <span class="operator">%</span> <span class="number">26</span>]
  shifted
<span class="keyword">end</span></code></pre>
        </div>
        <p>
          We can call <code>shift</code> to make sure it&#39;s working properly.
        </p>

        <div class="snippet undefined">
          <pre><code class="ptls"><span class="call">shift</span>(<span class="quotes">&quot;</span><span class="string">c</span><span class="quotes">&quot;</span>)
<span class="call">shift</span>(<span class="quotes">&quot;</span><span class="string">a</span><span class="quotes">&quot;</span>)
<span class="call">shift</span>(<span class="quotes">&quot;</span><span class="string">t</span><span class="quotes">&quot;</span>)</code></pre>
          <pre class="result" style="undefined"><code>&quot;p&quot;
&quot;n&quot;
&quot;g&quot;
</code></pre>
        </div>
        <hr />

        <h2 id="shifting-whole-strings">
          <a href="#shifting-whole-strings">Shifting Whole Strings</a>
        </h2>
        <p>
          Ultimately we want to be able to encode an entire string at once,
          instead of character-by-character. We&#39;ll define a new function
          <code>cipher</code> that takes a string <code>message</code>, calls
          the <code>shift</code> function for each letter in
          <code>message</code>, joins the shifted letters together, and returns
          the resulting encoded string.
        </p>

        <div class="snippet undefined">
          <pre><code class="ptls"><span class="keyword">fn</span> <span class="function">cipher</span>(<span class="argument">message</span>)
  message
    <span class="operator">|</span> <span class="call">chars</span>
    <span class="operator">$</span> <span class="call">shift</span>
    <span class="operator">|</span> <span class="call">join</span>(<span class="quotes">&quot;</span><span class="quotes">&quot;</span>)
<span class="keyword">end</span></code></pre>
        </div>
        <p>
          Like before, we&#39;re using the <code>chars(string)</code> function
          to transform a string (<code>message</code>) into a list of
          characters; however, this time we&#39;re calling it using
          <a href="/language/pipelines">pipeline syntax</a>. In this syntax, the
          pipe <code>|</code> operator calls the function that comes after it
          with the argument value that comes before it.
        </p>

        <div class="snippet undefined">
          <pre><code class="ptls"><span class="quotes">&quot;</span><span class="string">cat</span><span class="quotes">&quot;</span> <span class="operator">|</span> <span class="call">chars</span></code></pre>
          <pre
            class="result"
            style="undefined"
          ><code>[&quot;c&quot;, &quot;a&quot;, &quot;t&quot;]
</code></pre>
        </div>
        <p>In Pointless, the following two forms are equivalent.</p>

        <div class="snippet undefined">
          <pre><code class="ptls"><span class="call">chars</span>(message)
message <span class="operator">|</span> <span class="call">chars</span></code></pre>
        </div>
        <p>
          There&#39;s a second form of the pipeline syntax which uses the map
          <code>$</code> operator. Like the pipe <code>|</code> operator, the
          map <code>$</code> operator calls the function that comes after it
          with the argument value that comes before it, with a twist:
        </p>
        <ul>
          <li>
            It requires that its argument value is a list (or another iterable
            type).
          </li>
          <li>
            It calls the function on <strong>each</strong> element in the
            argument list.
          </li>
          <li>It returns the result of each of these calls as a new list.</li>
        </ul>

        <div class="snippet undefined">
          <pre><code class="ptls"><span class="quotes">&quot;</span><span class="string">cat</span><span class="quotes">&quot;</span> <span class="operator">|</span> <span class="call">chars</span> <span class="operator">$</span> <span class="call">shift</span></code></pre>
          <pre
            class="result"
            style="undefined"
          ><code>[&quot;p&quot;, &quot;n&quot;, &quot;g&quot;]
</code></pre>
        </div>
        <p>
          As a final step, the <code>cipher</code> function takes the list of
          shifted letters and passes them to the
          <code>join(values, sep)</code> function, which joins them together
          into a single string with the separator <code>sep</code> in between.
          We don&#39;t want anything between the letters, so we&#39;ll use an
          empty separator <code>&quot;&quot;</code>.
        </p>

        <div class="snippet undefined">
          <pre><code class="ptls"><span class="quotes">&quot;</span><span class="string">cat</span><span class="quotes">&quot;</span> <span class="operator">|</span> <span class="call">chars</span> <span class="operator">$</span> <span class="call">shift</span> <span class="operator">|</span> <span class="call">join</span>(<span class="quotes">&quot;</span><span class="quotes">&quot;</span>)</code></pre>
          <pre class="result" style="undefined"><code>&quot;png&quot;
</code></pre>
        </div>
        <p>
          Unlike <code>chars</code> and <code>shift</code>,
          <code>join</code> takes two arguments, <code>values</code> and
          <code>sep</code>. The pipe <code>|</code> operator will supply the
          first argument (<code>values</code>), but we need to specify a value
          for <code>sep</code> as well.
        </p>
        <p>In Pointless, the following two forms are equivalent.</p>

        <div class="snippet undefined">
          <pre><code class="ptls"><span class="call">join</span>(shifted, <span class="quotes">&quot;</span><span class="quotes">&quot;</span>)
shifted <span class="operator">|</span> <span class="call">join</span>(<span class="quotes">&quot;</span><span class="quotes">&quot;</span>)</code></pre>
        </div>
        <hr />

        <h2 id="encoding-and-decoding">
          <a href="#encoding-and-decoding">Encoding and Decoding</a>
        </h2>
        <p>
          Now let&#39;s call <code>cipher</code> to make sure it&#39;s working
          properly.
        </p>

        <div class="snippet undefined">
          <pre><code class="ptls"><span class="call">cipher</span>(<span class="quotes">&quot;</span><span class="string">cat</span><span class="quotes">&quot;</span>)
<span class="call">cipher</span>(<span class="quotes">&quot;</span><span class="string">png</span><span class="quotes">&quot;</span>)</code></pre>
          <pre class="result" style="undefined"><code>&quot;png&quot;
&quot;cat&quot;
</code></pre>
        </div>
        <p>
          This example shows us something interesting: if we pass an encoded
          string (like <code>&quot;png&quot;</code>) to <code>cipher</code>, we
          get back the original unencoded string! This happens because the ROT13
          cipher uses <code>13</code> as the shift value. When we call
          <code>cipher</code> on an encoded string, the encoded letters (which
          were already shifted <code>13</code> places from the original letters)
          are shifted <code>13</code> places again, bringing the total shift
          amount to <code>26</code>. Since our alphabet is
          <code>26</code> letters long, this process wraps each letter back to
          its original value.
          <strong
            >This means that we can use <code>cipher</code> for both encoding
            and decoding!</strong
          >
        </p>
        <p>
          We can verify this by calling <code>cipher</code> twice on the same
          message and checking that we get the original message back.
        </p>

        <div class="snippet undefined">
          <pre><code class="ptls"><span class="call">cipher</span>(<span class="call">cipher</span>(<span class="quotes">&quot;</span><span class="string">cat</span><span class="quotes">&quot;</span>))</code></pre>
          <pre class="result" style="undefined"><code>&quot;cat&quot;
</code></pre>
        </div>
        <hr />

        <h2 id="uppercase-letters">
          <a href="#uppercase-letters">Uppercase Letters</a>
        </h2>
        <p>Currently, our code looks like this.</p>

        <div class="snippet undefined">
          <pre><code class="ptls">alphabet <span class="operator">=</span> <span class="call">chars</span>(<span class="quotes">&quot;</span><span class="string">abcdefghijklmnopqrstuvwxyz</span><span class="quotes">&quot;</span>)

<span class="keyword">fn</span> <span class="function">shift</span>(<span class="argument">letter</span>)
  index <span class="operator">=</span> <span class="std">List</span>.<span class="call">indexOf</span>(alphabet, letter)
  shifted <span class="operator">=</span> alphabet[(index <span class="operator">+</span> <span class="number">13</span>) <span class="operator">%</span> <span class="number">26</span>]
  shifted
<span class="keyword">end</span>

<span class="keyword">fn</span> <span class="function">cipher</span>(<span class="argument">message</span>)
  message
    <span class="operator">|</span> <span class="call">chars</span>
    <span class="operator">$</span> <span class="call">shift</span>
    <span class="operator">|</span> <span class="call">join</span>(<span class="quotes">&quot;</span><span class="quotes">&quot;</span>)
<span class="keyword">end</span></code></pre>
        </div>
        <p>
          We still need to make a couple of changes. The first issue is
          uppercase letters: the <code>indexOf</code> function that we use in
          <code>shift</code> is case-sensitive, so our code won&#39;t work for
          messages containing uppercase letters. We can solve this by having
          <code>shift</code> convert <code>letter</code> to lowercase before
          finding its index.
        </p>

        <div class="snippet undefined">
          <pre><code class="ptls"><span class="keyword">fn</span> <span class="function">shift</span>(<span class="argument">letter</span>)
  index <span class="operator">=</span> <span class="std">List</span>.<span class="call">indexOf</span>(alphabet, <span class="std">Str</span>.<span class="call">toLower</span>(letter))
  shifted <span class="operator">=</span> alphabet[(index <span class="operator">+</span> <span class="number">13</span>) <span class="operator">%</span> <span class="number">26</span>]
  shifted
<span class="keyword">end</span></code></pre>
        </div>
        <p>
          This change allows <code>cipher</code> to handle uppercase letters,
          but we end up losing information about which letters were capitalized
          in the original message.
        </p>

        <div class="snippet undefined">
          <pre><code class="ptls"><span class="call">cipher</span>(<span class="quotes">&quot;</span><span class="string">Cat</span><span class="quotes">&quot;</span>)
<span class="call">cipher</span>(<span class="call">cipher</span>(<span class="quotes">&quot;</span><span class="string">Cat</span><span class="quotes">&quot;</span>))</code></pre>
          <pre class="result" style="undefined"><code>&quot;png&quot;
&quot;cat&quot;
</code></pre>
        </div>
        <p>
          We&#39;ll update the definition for our cipher so that uppercase
          letters in <code>message</code> get translated to uppercase letters in
          the final encoded string.
        </p>
        <pre><code>before encoding: a b c d e f g h i j k l m n o p q r s t u v w x y z
after encoded:   n o p q r s t u v w x y z a b c d e f g h i j k l m

before encoding: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
after encoded:   N O P Q R S T U V W X Y Z A B C D E F G H I J K L M</code></pre>
        <p>
          We can add this behavior to <code>shift</code> using a conditional
          expression. This conditional uses the
          <code>isUpper(string)</code> function (from the
          <code>str</code> module) to check whether <code>letter</code> is
          uppercase and convert <code>shifted</code> to uppercase when
          necessary.
        </p>

        <div class="snippet undefined">
          <pre><code class="ptls"><span class="keyword">fn</span> <span class="function">shift</span>(<span class="argument">letter</span>)
  index <span class="operator">=</span> <span class="std">List</span>.<span class="call">indexOf</span>(alphabet, <span class="std">Str</span>.<span class="call">toLower</span>(letter))
  shifted <span class="operator">=</span> alphabet[(index <span class="operator">+</span> <span class="number">13</span>) <span class="operator">%</span> <span class="number">26</span>]

  <span class="keyword">if</span> <span class="std">Str</span>.<span class="call">isUpper</span>(letter) <span class="keyword">then</span>
    <span class="std">Str</span>.<span class="call">toUpper</span>(shifted)
  <span class="keyword">else</span>
    shifted
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
        </div>
        <p>Our <code>cipher</code> function now preserves letter case.</p>

        <div class="snippet undefined">
          <pre><code class="ptls"><span class="call">cipher</span>(<span class="quotes">&quot;</span><span class="string">Cat</span><span class="quotes">&quot;</span>)
<span class="call">cipher</span>(<span class="call">cipher</span>(<span class="quotes">&quot;</span><span class="string">Cat</span><span class="quotes">&quot;</span>))</code></pre>
          <pre class="result" style="undefined"><code>&quot;Png&quot;
&quot;Cat&quot;
</code></pre>
        </div>
        <hr />

        <h2 id="non-alphabetic-characters">
          <a href="#non-alphabetic-characters">Non-Alphabetic Characters</a>
        </h2>
        <p>
          The final piece to consider is non-alphabetic characters. Currently,
          if we call <code>shift</code> with a non-alphabetic character (like
          <code>&quot;!&quot;</code>), the call to
          <code>List.indexOf</code> will return <code>none</code>. This will
          cause an error later when we try to do math with the
          <code>none</code> value as though it were a number. We can fix this by
          having <code>shift</code> check whether
          <code>List.indexOf</code> returned <code>none</code> and returning
          <code>letter</code> unmodified if it did.
        </p>

        <div class="snippet undefined">
          <pre><code class="ptls"><span class="keyword">fn</span> <span class="function">shift</span>(<span class="argument">letter</span>)
  index <span class="operator">=</span> <span class="std">List</span>.<span class="call">indexOf</span>(alphabet, <span class="std">Str</span>.<span class="call">toLower</span>(letter))

  <span class="keyword">if</span> index <span class="operator">==</span> <span class="constant">none</span> <span class="keyword">then</span>
    letter
  <span class="keyword">else</span>
    shifted <span class="operator">=</span> alphabet[(index <span class="operator">+</span> <span class="number">13</span>) <span class="operator">%</span> <span class="number">26</span>]

    <span class="keyword">if</span> <span class="std">Str</span>.<span class="call">isUpper</span>(letter) <span class="keyword">then</span>
      <span class="std">Str</span>.<span class="call">toUpper</span>(shifted)
    <span class="keyword">else</span>
      shifted
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
        </div>
        <p>
          Now <code>shift</code> and <code>cipher</code> will translate
          alphabetic characters and pass non-alphabetic characters through
          unmodified.
        </p>

        <div class="snippet undefined">
          <pre><code class="ptls"><span class="call">cipher</span>(<span class="quotes">&quot;</span><span class="string">Cat!</span><span class="quotes">&quot;</span>)
<span class="call">cipher</span>(<span class="call">cipher</span>(<span class="quotes">&quot;</span><span class="string">Cat!</span><span class="quotes">&quot;</span>))</code></pre>
          <pre class="result" style="undefined"><code>&quot;Png!&quot;
&quot;Cat!&quot;
</code></pre>
        </div>
        <p>Our code is now complete!</p>

        <hr />

        <h2 id="wrapping-up">
          <a href="#wrapping-up">Wrapping Up</a>
        </h2>
        <p>So, what&#39;s the secret message?</p>

        <div class="snippet undefined">
          <pre><code class="ptls"><span class="call">cipher</span>(<span class="quotes">&quot;</span><span class="string">Uryyb jbeyq!</span><span class="quotes">&quot;</span>)</code></pre>
          <pre class="result" style="undefined"><code>&quot;Hello world!&quot;
</code></pre>
        </div>

        <div id="sequencer">
          <hr />
          <div>
            <a class="next" href="/articles/first-digit">
              <div>Next ></div>
              First-Digit Law Tutorial
            </a>
          </div>
        </div>
      </main>
    </article>
  </body>
</html>
